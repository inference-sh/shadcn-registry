{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tools",
  "title": "Tool Invocation UI",
  "description": "Displays tool lifecycle: pending, in-progress, approval, and results.",
  "registryDependencies": [
    "badge",
    "button",
    "card",
    "collapsible",
    "spinner",
    "https://ui.inference.sh/r/widgets.json",
    "https://ui.inference.sh/r/task.json"
  ],
  "files": [
    {
      "path": "registry/blocks/tools/tool-invocation.tsx",
      "content": "/**\n * ToolInvocation Primitive\n * \n * Displays a single tool invocation with collapsible details, widget support,\n * and task output for app tools.\n */\n\nimport React, { memo, useState, useMemo, useCallback } from 'react';\nimport { cn } from '@/lib/utils';\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from '@/components/ui/collapsible';\nimport { MessageCircleCode, CheckCircle2, XCircle, Clock, AlertCircle, CheckCircle, CircleDashed } from 'lucide-react';\nimport { Spinner } from '@/components/ui/spinner';\nimport { Button } from '@/components/ui/button';\nimport {\n  ToolInvocationStatusPending,\n  ToolInvocationStatusInProgress,\n  ToolInvocationStatusAwaitingInput,\n  ToolInvocationStatusAwaitingApproval,\n  ToolInvocationStatusCompleted,\n  ToolInvocationStatusFailed,\n  ToolInvocationStatusCancelled,\n  ToolTypeApp,\n} from '@inferencesh/sdk';\nimport { useAgentActions, useAgentClient, type ToolInvocationDTO, type UploadedFile } from '@inferencesh/sdk/agent';\nimport { WidgetRenderer } from '@/components/infsh/agent/widget-renderer';\nimport { parseWidget, type WidgetAction, type WidgetFormData } from '@/components/infsh/agent/widget-types';\nimport { TaskOutputWrapper } from '@/components/infsh/task/task-output-wrapper';\n\n// Tool finish constants\nconst ToolFinishStatusSucceeded = 'succeeded';\nconst ToolFinishStatusFailed = 'failed';\nconst ToolFinishStatusCancelled = 'cancelled';\n\n// Types\ninterface ToolFinish {\n  status: string;\n  result?: unknown;\n  error?: string;\n}\n\ninterface ToolInvocationProps {\n  invocation: ToolInvocationDTO;\n  className?: string;\n  defaultOpen?: boolean;\n}\n\n// ============================================================================\n// Finish Block - Special display for finish tool marking end of chat\n// ============================================================================\n\nconst FinishBlock = memo(function FinishBlock({\n  finish,\n  isActive = false,\n}: {\n  finish?: ToolFinish | null\n  isActive?: boolean\n}) {\n  const getStatusIcon = () => {\n    if (isActive) {\n      return <Spinner className=\"size-3.5\" />\n    }\n    switch (finish?.status) {\n      case ToolFinishStatusSucceeded:\n        return <CheckCircle className=\"h-3.5 w-3.5 text-emerald-400\" />\n      case ToolFinishStatusFailed:\n        return <XCircle className=\"h-3.5 w-3.5 text-red-400\" />\n      case ToolFinishStatusCancelled:\n        return <CircleDashed className=\"h-3.5 w-3.5 text-muted-foreground\" />\n      default:\n        return <CheckCircle className=\"h-3.5 w-3.5 text-emerald-400\" />\n    }\n  }\n\n  const getStatusText = () => {\n    if (isActive) return 'finishing'\n    switch (finish?.status) {\n      case ToolFinishStatusSucceeded:\n        return 'completed'\n      case ToolFinishStatusFailed:\n        return 'failed'\n      case ToolFinishStatusCancelled:\n        return 'cancelled'\n      default:\n        return 'completed'\n    }\n  }\n\n  const getLineColor = () => {\n    switch (finish?.status) {\n      case ToolFinishStatusFailed:\n        return 'bg-red-400/30'\n      case ToolFinishStatusCancelled:\n        return 'bg-muted-foreground/30'\n      default:\n        return 'bg-muted-foreground/20'\n    }\n  }\n\n  const resultMessage = finish?.result && typeof finish.result === 'string' && !isActive\n    ? finish.result.toLowerCase()\n    : null;\n\n  return (\n    <div className=\"my-6 w-full\">\n      <div className=\"flex items-center gap-4 w-full\">\n        <div className={cn(\"flex-1 h-px\", getLineColor())} />\n        <div className={cn(\n          \"flex items-center gap-2 text-muted-foreground/50\",\n          isActive && \"animate-pulse\"\n        )}>\n          {getStatusIcon()}\n          <span className=\"text-xs font-medium\">\n            {getStatusText()}\n          </span>\n        </div>\n        <div className={cn(\"flex-1 h-px\", getLineColor())} />\n      </div>\n      {resultMessage && (\n        <p className=\"text-xs text-muted-foreground/40 text-center mt-2 break-words\">\n          {resultMessage}\n        </p>\n      )}\n    </div>\n  )\n})\n\n/**\n * ToolInvocation - Single tool call display with widget and task output support\n * \n * @example\n * ```tsx\n * <ToolInvocation invocation={toolInvocation} />\n * ```\n */\nexport const ToolInvocation = memo(function ToolInvocation({\n  invocation,\n  className,\n  defaultOpen = false,\n}: ToolInvocationProps) {\n  // Parse widget from result or data - moved up to check for auto-open\n  const widget = useMemo(() => {\n    // Try to parse from widget field first\n    if (invocation.widget) {\n      return parseWidget(invocation.widget);\n    }\n    // Try to parse from result\n    if (invocation.result) {\n      return parseWidget(invocation.result);\n    }\n    return null;\n  }, [invocation.widget, invocation.result]);\n\n  // Default to open for awaiting approval so users can see what they're approving\n  // Also default to open for widgets so users can see them immediately\n  const isAwaitingApprovalStatus = invocation.status === ToolInvocationStatusAwaitingApproval;\n  const [isOpen, setIsOpen] = useState(defaultOpen || isAwaitingApprovalStatus || !!widget);\n\n  // Get actions: submitToolResult for widgets, approveTool/rejectTool/alwaysAllowTool for HIL approval\n  // sendMessage for completed widget actions (e.g., \"Create Variation\" on finished images)\n  const { submitToolResult, approveTool, rejectTool, alwaysAllowTool, sendMessage } = useAgentActions();\n  // Get client for TaskOutputWrapper\n  const client = useAgentClient();\n\n  // Tool names are now direct (no type prefix) - use as-is\n  const functionName = invocation.function?.name || 'tool';\n\n  const status = invocation.status;\n  const isActive =\n    status === ToolInvocationStatusInProgress ||\n    status === ToolInvocationStatusAwaitingInput ||\n    status === ToolInvocationStatusPending;\n\n  // Check if this is an app tool with an execution_id (task)\n  const isAppTool = invocation.type === ToolTypeApp;\n\n  // Try to get task ID from execution_id, or parse from result as fallback\n  const taskId = useMemo(() => {\n    // First try the execution_id field\n    if (invocation.execution_id) {\n      return invocation.execution_id;\n    }\n    // Fallback: try to parse task ID from result text\n    // Result format: \"Task {task_id} {app_name} completed with output: ...\"\n    if (isAppTool && typeof invocation.result === 'string') {\n      const match = invocation.result.match(/^Task\\s+([a-z0-9]+)\\s+/);\n      if (match) {\n        return match[1];\n      }\n    }\n    return null;\n  }, [invocation.execution_id, invocation.result, isAppTool]);\n\n  const hasTaskOutput = isAppTool && taskId;\n\n  // Check if this is a finish tool - render with special FinishBlock component\n  const isFinishTool = functionName === 'finish';\n\n  // Parse finish data from invocation.data (where backend stores ToolFinish)\n  const finishData = useMemo((): ToolFinish | null => {\n    if (!isFinishTool) return null;\n\n    // Try to parse from data field (where backend stores structured ToolFinish)\n    if (invocation.data) {\n      try {\n        // data might be a string or already parsed object\n        const data = typeof invocation.data === 'string'\n          ? JSON.parse(invocation.data)\n          : invocation.data;\n        // Check if it looks like a ToolFinish (has status field)\n        if (data && typeof data.status === 'string') {\n          return data as ToolFinish;\n        }\n      } catch {\n        // Not valid JSON or not a ToolFinish\n      }\n    }\n\n    // Fallback: try to parse from arguments (for in-progress invocations)\n    if (invocation.function?.arguments) {\n      const args = invocation.function.arguments;\n      if (args.status && typeof args.status === 'string') {\n        return {\n          status: args.status as string,\n          result: args.result as string | undefined,\n        };\n      }\n    }\n\n    return null;\n  }, [isFinishTool, invocation.data, invocation.function?.arguments]);\n\n\n  const statusIcon = useMemo(() => {\n    switch (status) {\n      case ToolInvocationStatusPending:\n      case ToolInvocationStatusInProgress:\n        return <Spinner className=\"size-3\" />;\n      case ToolInvocationStatusAwaitingInput:\n      case ToolInvocationStatusAwaitingApproval:\n        return <Clock className=\"h-3 w-3\" />;\n      case ToolInvocationStatusCompleted:\n        return <CheckCircle2 className=\"h-3 w-3 text-emerald-400\" />;\n      case ToolInvocationStatusFailed:\n        return <AlertCircle className=\"h-3 w-3 text-red-400\" />;\n      case ToolInvocationStatusCancelled:\n        return <XCircle className=\"h-3 w-3 text-muted-foreground\" />;\n      default:\n        return <MessageCircleCode className=\"h-3 w-3\" />;\n    }\n  }, [status]);\n\n  const statusText = useMemo(() => {\n    switch (status) {\n      case ToolInvocationStatusPending:\n        return 'pending';\n      case ToolInvocationStatusInProgress:\n        return 'running';\n      case ToolInvocationStatusAwaitingInput:\n        return 'awaiting input';\n      case ToolInvocationStatusAwaitingApproval:\n        return 'awaiting approval';\n      case ToolInvocationStatusCompleted:\n        return 'completed';\n      case ToolInvocationStatusFailed:\n        return 'failed';\n      case ToolInvocationStatusCancelled:\n        return 'cancelled';\n      default:\n        return '';\n    }\n  }, [status]);\n\n\n  // Handle widget actions\n  // - For awaiting_input: Submit tool result to continue current turn\n  // - For completed: Send new message with action context (e.g., \"Create Variation\" on finished images)\n  const handleWidgetAction = useCallback(async (action: WidgetAction, formData?: WidgetFormData) => {\n    const isAwaitingInput = status === ToolInvocationStatusAwaitingInput;\n\n    if (isAwaitingInput) {\n      // Awaiting input: submit tool result to continue current turn\n      if (!submitToolResult) return;\n      try {\n        await submitToolResult(invocation.id, JSON.stringify({ action, form_data: formData }));\n      } catch (error) {\n        console.error('[ToolInvocation] Failed to submit widget action:', error);\n      }\n    } else {\n      // Completed/other: send as new message to start a new turn\n      if (!sendMessage) return;\n      try {\n        // Build message text from action\n        const actionText = action.payload?.message || action.payload?.text || action.type;\n        // Include image URI if present in payload (for image variations)\n        const files: UploadedFile[] = [];\n        if (action.payload?.image_uri) {\n          files.push({ uri: action.payload.image_uri as string, content_type: 'image/png' });\n        }\n        await sendMessage(String(actionText), files.length > 0 ? files : undefined);\n      } catch (error) {\n        console.error('[ToolInvocation] Failed to send widget action as message:', error);\n      }\n    }\n  }, [invocation.id, status, submitToolResult, sendMessage]);\n\n  // Handle approve/reject for HIL approval (separate from widget submission)\n  const handleApprove = useCallback(async () => {\n    try {\n      await approveTool(invocation.id);\n    } catch (error) {\n      console.error('[ToolInvocation] Failed to approve:', error);\n    }\n  }, [invocation.id, approveTool]);\n\n  const handleReject = useCallback(async () => {\n    try {\n      await rejectTool(invocation.id);\n    } catch (error) {\n      console.error('[ToolInvocation] Failed to reject:', error);\n    }\n  }, [invocation.id, rejectTool]);\n\n  const handleAlwaysAllow = useCallback(async () => {\n    try {\n      await alwaysAllowTool(invocation.id, functionName);\n    } catch (error) {\n      console.error('[ToolInvocation] Failed to always-allow:', error);\n    }\n  }, [invocation.id, functionName, alwaysAllowTool]);\n\n  const hasArgs =\n    invocation.function?.arguments &&\n    Object.keys(invocation.function.arguments).length > 0;\n  // Note: hasResult only applies when there's no widget (widgets are handled separately)\n  const hasResult = !!invocation.result && !widget && !hasTaskOutput;\n\n  // Widget is interactive when awaiting input OR completed (for actions like \"Create Variation\")\n  const isWidgetInteractive = status === ToolInvocationStatusAwaitingInput ||\n    status === ToolInvocationStatusCompleted;\n\n  // For finish tool with standard schema (has status field), use custom FinishBlock\n  // For custom output schemas, fall through to widget rendering\n  if (isFinishTool && (finishData || isActive)) {\n    return (\n      <FinishBlock\n        finish={finishData}\n        isActive={isActive}\n      />\n    );\n  }\n\n  // For awaiting approval, show approval UI\n  if (isAwaitingApprovalStatus) {\n    // If there's a widget, use it\n    if (widget) {\n      return (\n        <div className={cn('flex flex-col items-start', className)}>\n          <WidgetRenderer\n            widget={widget}\n            onAction={handleWidgetAction}\n            className=\"max-w-md\"\n          />\n        </div>\n      );\n    }\n\n    // Otherwise show default approval UI with buttons in footer\n    return (\n      <div className={cn('flex flex-col items-start', className)}>\n        <div className=\"overflow-hidden rounded border bg-muted/10\">\n          {/* Header */}\n          <div className=\"flex items-center gap-1.5 px-2 py-1.5 text-xs text-muted-foreground\">\n            {statusIcon}\n            <span className=\"lowercase\">\n              {functionName} {statusText}\n            </span>\n          </div>\n\n          {/* Arguments */}\n          {hasArgs && (\n            <div className=\"border-t px-2 py-1.5 text-xs\">\n              <div className=\"text-muted-foreground/50 mb-1\">arguments:</div>\n              <pre className=\"text-muted-foreground whitespace-pre-wrap overflow-y-auto max-h-[150px]\">\n                {JSON.stringify(invocation.function?.arguments, null, 2)}\n              </pre>\n            </div>\n          )}\n\n          {/* Footer with action buttons */}\n          <div className=\"flex items-center justify-end gap-2 border-t px-2 py-1.5\">\n            <Button\n              size=\"sm\"\n              variant=\"ghost\"\n              className=\"h-6 px-2 text-xs text-muted-foreground hover:text-foreground\"\n              onClick={handleReject}\n            >\n              skip\n            </Button>\n            <Button\n              size=\"sm\"\n              variant=\"ghost\"\n              className=\"h-6 px-2 text-xs text-emerald-400 hover:text-emerald-400/80 hover:bg-emerald-400/10\"\n              onClick={handleApprove}\n            >\n              allow\n            </Button>\n            <Button\n              size=\"sm\"\n              variant=\"ghost\"\n              className=\"h-6 px-2 text-xs text-blue-400 hover:text-blue-400/80 hover:bg-blue-400/10\"\n              onClick={handleAlwaysAllow}\n            >\n              always allow\n            </Button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  // For app tools with task output, show the TaskOutputWrapper\n  if (hasTaskOutput) {\n    return (\n      <div className={cn('flex flex-col items-start', className)}>\n        <Collapsible\n          open={isOpen}\n          onOpenChange={setIsOpen}\n          className={cn(\n            'group w-full overflow-hidden rounded text-muted-foreground',\n            isOpen && 'border bg-muted/10'\n          )}\n        >\n          <div className=\"flex items-center px-1 py-0.5\">\n            <CollapsibleTrigger asChild>\n              <button className=\"flex items-center gap-1.5 text-xs text-muted-foreground/50 hover:text-muted-foreground cursor-pointer\">\n                {statusIcon}\n                <span className={cn('lowercase', isActive && 'animate-pulse')}>\n                  {functionName} {statusText}\n                </span>\n              </button>\n            </CollapsibleTrigger>\n          </div>\n          <CollapsibleContent>\n            <div className=\"border-t p-2\">\n              <TaskOutputWrapper client={client} taskId={taskId!} compact={true} />\n            </div>\n          </CollapsibleContent>\n        </Collapsible>\n      </div>\n    );\n  }\n\n  // Render widget if present\n  if (widget) {\n    return (\n      <div className={cn('flex flex-col items-start flex-grow-0', className)}>\n        <WidgetRenderer\n          widget={widget}\n          onAction={handleWidgetAction}\n          disabled={!isWidgetInteractive}\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn('flex flex-col items-start w-fit', className)}>\n      <Collapsible\n        open={isOpen}\n        onOpenChange={setIsOpen}\n        className={cn(\n          'group w-full overflow-hidden rounded text-muted-foreground',\n          isOpen && 'border bg-muted/10'\n        )}\n      >\n        <div className=\"flex items-center px-1 py-0.5\">\n          <CollapsibleTrigger asChild>\n            <button className=\"flex items-center gap-1.5 text-xs text-muted-foreground/50 hover:text-muted-foreground cursor-pointer\">\n              {statusIcon}\n              <span className={cn('lowercase', isActive && 'animate-pulse')}>\n                {functionName} {statusText}\n              </span>\n            </button>\n          </CollapsibleTrigger>\n        </div>\n        <CollapsibleContent>\n          <div className=\"border-t px-2 py-1.5 text-xs space-y-1.5\">\n            {hasArgs && (\n              <div>\n                <div className=\"text-muted-foreground/50 mb-1\">arguments:</div>\n                <pre className=\"text-muted-foreground whitespace-pre-wrap overflow-y-auto max-h-[150px]\">\n                  {JSON.stringify(invocation.function?.arguments, null, 2)}\n                </pre>\n              </div>\n            )}\n            {/* Render raw result (widgets are handled separately above) */}\n            {hasResult && (\n              <div>\n                <div className=\"text-muted-foreground/50 mb-1\">result:</div>\n                <pre className=\"text-foreground whitespace-pre-wrap overflow-y-auto max-h-[150px]\">\n                  {typeof invocation.result === 'string'\n                    ? invocation.result\n                    : JSON.stringify(invocation.result, null, 2)}\n                </pre>\n              </div>\n            )}\n          </div>\n        </CollapsibleContent>\n      </Collapsible>\n    </div>\n  );\n});\n\nToolInvocation.displayName = 'ToolInvocation';\n",
      "type": "registry:component",
      "target": "components/infsh/agent/tool-invocation.tsx"
    },
    {
      "path": "registry/blocks/tools/tool-invocations.tsx",
      "content": "/**\n * ToolInvocations Primitive\n * \n * Displays all tool invocations for a message.\n */\n\nimport React, { memo } from 'react';\nimport { cn } from '@/lib/utils';\nimport { ToolInvocation } from '@/components/infsh/agent/tool-invocation';\nimport type { ChatMessageDTO } from '@inferencesh/sdk/agent';\n\ninterface ToolInvocationsProps {\n  message: ChatMessageDTO;\n  className?: string;\n}\n\n/**\n * ToolInvocations - List of tool calls for a message\n * \n * @example\n * ```tsx\n * <ToolInvocations message={message} />\n * ```\n */\nexport const ToolInvocations = memo(function ToolInvocations({\n  message,\n  className,\n}: ToolInvocationsProps) {\n  const invocations = message.tool_invocations;\n\n  if (!invocations || invocations.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={cn('mt-2 space-y-1', className)}>\n      {invocations.map((invocation, idx) => (\n        <ToolInvocation key={invocation.id || idx} invocation={invocation} />\n      ))}\n    </div>\n  );\n});\n\nToolInvocations.displayName = 'ToolInvocations';\n\n",
      "type": "registry:component",
      "target": "components/infsh/agent/tool-invocations.tsx"
    }
  ],
  "type": "registry:block"
}