{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "agent",
  "type": "registry:block",
  "title": "Agent Chat",
  "description": "Full-featured AI agent chat with state management, tools, and widgets.",
  "dependencies": [
    "@inferencesh/sdk"
  ],
  "registryDependencies": [
    "button",
    "https://ui.inference.sh/r/chat.json",
    "https://ui.inference.sh/r/tools.json",
    "https://ui.inference.sh/r/widgets.json"
  ],
  "files": [
    {
      "path": "registry/blocks/agent/agent.tsx",
      "content": "/**\n * Agent - Pre-composed Chat Component\n * \n * Ready-to-use chat UI built from primitives.\n */\n\nimport React, { memo, useMemo } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Bot } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport {\n  Inference,\n  ChatMessageStatusReady,\n  ChatMessageStatusFailed,\n  ChatMessageStatusCancelled,\n  ChatMessageRoleUser,\n  ChatMessageRoleAssistant,\n  ChatMessageContentTypeReasoning,\n  ChatMessageContentTypeText,\n} from '@inferencesh/sdk';\nimport { AgentProvider } from '@/components/agent/provider';\nimport { useAgent, useAgentActions } from '@/hooks/use-agent';\nimport { ChatContainer } from '@/components/agent/chat-container';\nimport { ChatMessages } from '@/components/agent/chat-messages';\nimport { ChatInput } from '@/components/agent/chat-input';\nimport { MessageBubble } from '@/components/agent/message-bubble';\nimport { MessageContent } from '@/components/agent/message-content';\nimport { MessageReasoning } from '@/components/agent/message-reasoning';\nimport { MessageStatusIndicator } from '@/components/agent/message-status-indicator';\nimport { ToolInvocations } from '@/components/agent/tool-invocations';\nimport type { AgentProps, ChatMessageDTO, AdHocAgentConfig } from '@/components/agent/types';\nimport { isAdHocConfig } from '@/components/agent/types';\n\n// Check if message status is terminal (generation complete)\nfunction isTerminalStatus(status: string | undefined): boolean {\n  return status === ChatMessageStatusReady ||\n    status === ChatMessageStatusFailed ||\n    status === ChatMessageStatusCancelled;\n}\n\n// =============================================================================\n// Helper functions\n// =============================================================================\n\nfunction getTextContent(message: ChatMessageDTO): string {\n  const textContent = message.content.find((c) => c.type === ChatMessageContentTypeText);\n  return textContent?.text ?? '';\n}\n\nfunction getReasoningContent(message: ChatMessageDTO): string | undefined {\n  const reasoningContent = message.content.find((c) => c.type === ChatMessageContentTypeReasoning);\n  return reasoningContent?.text;\n}\n\nfunction hasTextContent(message: ChatMessageDTO): boolean {\n  return message.content.some((c) => c.type === ChatMessageContentTypeText && c.text?.trim());\n}\n\n// =============================================================================\n// Internal Components\n// =============================================================================\n\nconst DefaultHeader = memo(function DefaultHeader({\n  config,\n}: {\n  config: AdHocAgentConfig;\n}) {\n  return (\n    <div className=\"flex items-center gap-2 px-4 py-3 border-b\">\n      <Bot className=\"h-4 w-4 text-primary\" />\n      <span className=\"font-medium text-sm\">agent</span>\n    </div>\n  );\n});\n\nconst ExamplePrompts = memo(function ExamplePrompts({\n  prompts,\n  onSelect,\n}: {\n  prompts: string[];\n  onSelect: (prompt: string) => void;\n}) {\n  if (prompts.length === 0) return null;\n\n  return (\n    <div className=\"mt-4 space-y-2 w-full max-w-md\">\n      {prompts.map((prompt, idx) => (\n        <Button\n          key={idx}\n          variant=\"outline\"\n          onClick={() => onSelect(prompt)}\n          className=\"w-full text-left justify-start h-auto py-2 px-3 text-sm whitespace-normal\"\n        >\n          {prompt}\n        </Button>\n      ))}\n    </div>\n  );\n});\n\nconst EmptyState = memo(function EmptyState({\n  config,\n}: {\n  config: AdHocAgentConfig;\n}) {\n  const { sendMessage } = useAgentActions();\n  const examplePrompts = config.example_prompts || [];\n\n  return (\n    <div className=\"flex-1 flex flex-col items-center justify-center text-center p-6 text-muted-foreground\">\n      <Bot className=\"h-8 w-8 mb-3 opacity-50\" />\n      <p className=\"text-sm font-medium\">how can I help?</p>\n      <p className=\"text-xs mt-1 opacity-70\">\n        {config.description || 'ask me anything'}\n      </p>\n      {examplePrompts.length > 0 && (\n        <ExamplePrompts prompts={examplePrompts} onSelect={sendMessage} />\n      )}\n    </div>\n  );\n});\n\nconst MessageRow = memo(function MessageRow({\n  message,\n  isLast,\n}: {\n  message: ChatMessageDTO;\n  isLast: boolean;\n}) {\n  const isUser = message.role === ChatMessageRoleUser;\n  const isAssistant = message.role === ChatMessageRoleAssistant;\n  const reasoningContent = getReasoningContent(message);\n  const isGenerating = !isTerminalStatus(message.status);\n  const hasTools = message.tool_invocations && message.tool_invocations.length > 0;\n\n  if (message.role === 'tool') {\n    return null;\n  }\n\n  if (!hasTextContent(message) && !reasoningContent && !hasTools) {\n    return null;\n  }\n\n  return (\n    <MessageBubble message={message}>\n      {isAssistant && reasoningContent && (\n        <MessageReasoning\n          reasoning={reasoningContent}\n          isReasoning={isGenerating && !hasTextContent(message)}\n        />\n      )}\n      <MessageContent message={message} truncate={isUser} />\n      {isAssistant && <ToolInvocations message={message} />}\n      {isAssistant && isGenerating && <MessageStatusIndicator />}\n    </MessageBubble>\n  );\n});\n\nconst MessageList = memo(function MessageList({\n  messages,\n  isGenerating,\n}: {\n  messages: ChatMessageDTO[];\n  isGenerating: boolean;\n}) {\n  // Show typing indicator when generating and last message is user or has no content yet\n  const lastMessage = messages[messages.length - 1];\n  const showTyping =\n    isGenerating &&\n    (!lastMessage ||\n      lastMessage.role === 'user' ||\n      !lastMessage.content?.some(c => c.type === 'text' && c.text?.trim()));\n\n  return (\n    <div className=\"space-y-4 p-4\">\n      {messages.map((message, index) => (\n        <MessageRow\n          key={message.id}\n          message={message}\n          isLast={index === messages.length - 1}\n        />\n      ))}\n      {showTyping && <MessageStatusIndicator label=\"thinking...\" />}\n    </div>\n  );\n});\n\nconst AgentContent = memo(function AgentContent({\n  config,\n  className,\n  compact,\n  allowFiles = true,\n  allowImages = true,\n}: {\n  config: AdHocAgentConfig;\n  className?: string;\n  compact?: boolean;\n  allowFiles?: boolean;\n  allowImages?: boolean;\n}) {\n  const { messages, isGenerating } = useAgent();\n  const hasMessages = messages.length > 0;\n\n  return (\n    <ChatContainer className={cn('h-full p-2', className)}>\n      {!compact && <DefaultHeader config={config} />}\n      {hasMessages ? (\n        <ChatMessages className=\"flex-1\">\n          {({ messages }) => <MessageList messages={messages} isGenerating={isGenerating} />}\n        </ChatMessages>\n      ) : (\n        <EmptyState config={config} />\n      )}\n      <ChatInput allowFiles={allowFiles} allowImages={allowImages} />\n    </ChatContainer>\n  );\n});\n\n// =============================================================================\n// Main Component\n// =============================================================================\n\nexport function Agent({\n  proxyUrl,\n  apiKey,\n  config,\n  name,\n  chatId,\n  className,\n  compact = false,\n  allowFiles = true,\n  allowImages = true,\n  onChatCreated,\n}: AgentProps) {\n  // Create client internally - memoized to prevent re-creation\n  const client = useMemo(() => {\n    if (!proxyUrl && !apiKey) {\n      console.error('[Agent] Either proxyUrl or apiKey is required');\n      return null;\n    }\n    return new Inference({ proxyUrl, apiKey });\n  }, [proxyUrl, apiKey]);\n\n  if (!client) {\n    return null;\n  }\n\n  if (!isAdHocConfig(config)) {\n    console.warn('[Agent] Template configs not yet supported. Use AgentProvider with primitives instead.');\n    return null;\n  }\n\n  return (\n    <AgentProvider\n      client={client}\n      config={config}\n      name={name}\n      chatId={chatId}\n      onChatCreated={onChatCreated}\n    >\n      <AgentContent\n        config={config}\n        className={className}\n        compact={compact}\n        allowFiles={allowFiles}\n        allowImages={allowImages}\n      />\n    </AgentProvider>\n  );\n}\n\nAgent.displayName = 'Agent';\n",
      "type": "registry:component",
      "target": "components/agent/agent.tsx"
    },
    {
      "path": "registry/blocks/agent/provider.tsx",
      "content": "/**\n * Agent Chat Provider\n * \n * Uses React useReducer + Context with SDK Agent for API operations.\n */\n\nimport React, { useReducer, useRef, useEffect, useMemo } from 'react';\nimport type { Agent, Inference } from '@inferencesh/sdk';\nimport { AgentContext, type AgentContextValue } from '@/components/agent/context';\nimport { chatReducer, initialState } from '@/components/agent/lib/reducer';\nimport { createActions, getClientToolHandlers, type ActionsContext, type ActionsResult } from '@/components/agent/lib/actions';\nimport type { AgentProviderProps, AgentOptions, AgentUIStatus, ClientToolHandlerFn } from '@/components/agent/types';\n\n/**\n * AgentProvider - Provides chat state and actions to children\n * \n * @example\n * ```tsx\n * const client = new Inference({ proxyUrl: '/api/inference/proxy' });\n * \n * <AgentProvider \n *   client={client}\n *   agentConfig={{ core_app_ref: 'openrouter/claude-sonnet-4@abc123' }}\n * >\n *   <MyChatUI />\n * </AgentProvider>\n * ```\n */\nexport function AgentProvider({\n  client,\n  config,\n  name,\n  chatId,\n  onChatCreated,\n  onStatusChange,\n  onError,\n  children,\n}: AgentProviderProps) {\n  // Core state via useReducer\n  const [state, dispatch] = useReducer(chatReducer, initialState);\n\n  // Refs for mutable values that actions need access to\n  const clientRef = useRef<Inference>(client);\n  const agentRef = useRef<Agent | null>(null);\n  const configRef = useRef<AgentOptions | null>(config);\n  const agentNameRef = useRef<string | undefined>(name);\n  const chatIdRef = useRef<string | null>(chatId ?? null);\n  const clientToolHandlersRef = useRef<Map<string, ClientToolHandlerFn>>(\n    getClientToolHandlers(config)\n  );\n  const callbacksRef = useRef<{\n    onChatCreated?: (chatId: string) => void;\n    onStatusChange?: (status: AgentUIStatus) => void;\n    onError?: (error: Error) => void;\n  }>({ onChatCreated, onStatusChange, onError });\n\n  // Keep refs in sync with props\n  useEffect(() => {\n    clientRef.current = client;\n  }, [client]);\n\n  useEffect(() => {\n    configRef.current = config;\n    agentNameRef.current = name;\n    clientToolHandlersRef.current = getClientToolHandlers(config);\n  }, [config, name]);\n\n  useEffect(() => {\n    callbacksRef.current = { onChatCreated, onStatusChange, onError };\n  }, [onChatCreated, onStatusChange, onError]);\n\n  // Keep chatIdRef synced with state\n  useEffect(() => {\n    chatIdRef.current = state.chatId;\n  }, [state.chatId]);\n\n  // Create actions once (they use refs internally)\n  const actionsContext = useMemo<ActionsContext>(() => ({\n    dispatch,\n    getClient: () => clientRef.current,\n    getAgent: () => agentRef.current,\n    setAgent: (agent) => { agentRef.current = agent; },\n    getConfig: () => configRef.current,\n    getAgentName: () => agentNameRef.current,\n    getChatId: () => chatIdRef.current,\n    getClientToolHandlers: () => clientToolHandlersRef.current,\n    callbacks: callbacksRef.current,\n  }), []);\n\n  // Re-bind callbacks when they change\n  useEffect(() => {\n    actionsContext.callbacks = callbacksRef.current;\n  }, [actionsContext, onChatCreated, onStatusChange, onError]);\n\n  const actionsResultRef = useRef<ActionsResult | null>(null);\n  if (!actionsResultRef.current) {\n    actionsResultRef.current = createActions(actionsContext);\n  }\n  const { publicActions, internalActions } = actionsResultRef.current;\n\n  // Handle initial chatId or chatId changes\n  useEffect(() => {\n    if (chatId && chatId !== state.chatId) {\n      internalActions.setChatId(chatId);\n    }\n  }, [chatId, state.chatId, internalActions]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      internalActions.stopStream();\n    };\n  }, [internalActions]);\n\n  const contextValue = useMemo<AgentContextValue>(() => ({\n    state,\n    actions: publicActions,\n    client,\n  }), [state, publicActions, client]);\n\n  return (\n    <AgentContext.Provider value={contextValue}>\n      {children}\n    </AgentContext.Provider>\n  );\n}\n\nAgentProvider.displayName = 'AgentProvider';\n",
      "type": "registry:component",
      "target": "components/agent/provider.tsx"
    },
    {
      "path": "registry/blocks/agent/context.tsx",
      "content": "/**\n * Agent Chat Context\n * \n * React context for agent chat state and actions.\n */\n\nimport { createContext } from 'react';\nimport type { Inference } from '@inferencesh/sdk';\nimport type { AgentState, AgentActions } from '@/components/agent/types';\n\nexport interface AgentContextValue {\n    state: AgentState;\n    actions: AgentActions;\n    client: Inference;\n}\n\nexport const AgentContext = createContext<AgentContextValue | null>(null);\n",
      "type": "registry:component",
      "target": "components/agent/context.tsx"
    },
    {
      "path": "registry/blocks/agent/types.ts",
      "content": "/**\n * Agent Chat Types\n * \n * Types for the Agent Chat component, using @inferencesh/sdk types.\n */\n\nimport type { ReactNode } from 'react';\nimport type {\n    Inference,\n    ChatMessageDTO,\n    ChatDTO,\n    ToolInvocationDTO,\n    ChatMessageContent,\n    ChatMessageRole,\n    TaskStatus,\n    AgentTool,\n    AgentConfig,\n    File as FileDTO,\n} from '@inferencesh/sdk';\n\n// Re-export SDK types for consumers\nexport type {\n    ChatMessageDTO,\n    ChatDTO,\n    ToolInvocationDTO,\n    ChatMessageContent,\n    ChatMessageRole,\n    TaskStatus,\n};\n\n// =============================================================================\n// Agent Configuration\n// =============================================================================\n\n/**\n * Ad-hoc agent configuration - uses SDK's AgentConfig\n * Can include ClientTool for browser-executed handlers\n */\nexport type AdHocAgentConfig = Omit<AgentConfig, 'tools'> & {\n    /** Tools with optional client-side handlers */\n    tools?: (AgentTool | ClientTool)[];\n};\n\n/**\n * Template agent configuration\n */\nexport interface TemplateAgentConfig {\n    /** Agent reference: namespace/name@shortid */\n    agent: string;\n}\n\n/**\n * Union type for agent options\n */\nexport type AgentOptions = AdHocAgentConfig | TemplateAgentConfig;\n\n/**\n * Type guard for ad-hoc config\n */\nexport function isAdHocConfig(config: AgentOptions): config is AdHocAgentConfig {\n    return 'core_app_ref' in config;\n}\n\n/**\n * Type guard for template config\n */\nexport function isTemplateConfig(config: AgentOptions): config is TemplateAgentConfig {\n    return 'agent' in config;\n}\n\n// =============================================================================\n// Chat State\n// =============================================================================\n\nexport type AgentUIStatus = 'idle' | 'connecting' | 'streaming' | 'error';\n\nexport interface AgentState {\n    chatId: string | null;\n    messages: ChatMessageDTO[];\n    status: AgentUIStatus;\n    isGenerating: boolean;\n    error?: string;\n    chat: ChatDTO | null;\n}\n\nexport interface AgentActions {\n    sendMessage: (text: string, files?: (Blob | FileDTO)[]) => Promise<void>;\n    stopGeneration: () => void;\n    reset: () => void;\n    clearError: () => void;\n    submitToolResult: (toolInvocationId: string, result: string) => Promise<void>;\n    approveTool: (toolInvocationId: string) => Promise<void>;\n    rejectTool: (toolInvocationId: string, reason?: string) => Promise<void>;\n    alwaysAllowTool: (toolInvocationId: string, toolName: string) => Promise<void>;\n}\n\n// =============================================================================\n// Provider Props\n// =============================================================================\n\nexport interface AgentProviderProps {\n    /** Inference SDK client instance */\n    client: Inference;\n    /** Agent configuration (ad-hoc or template reference) */\n    config: AgentOptions;\n    /** Optional name for ad-hoc agents (used for deduplication and display) */\n    name?: string;\n    /** Optional existing chat ID to continue */\n    chatId?: string;\n    /** Callback when a new chat is created */\n    onChatCreated?: (chatId: string) => void;\n    /** Callback when chat status changes */\n    onStatusChange?: (status: AgentUIStatus) => void;\n    /** Callback when an error occurs */\n    onError?: (error: Error) => void;\n    /** Children */\n    children: ReactNode;\n}\n\n// =============================================================================\n// Component Props\n// =============================================================================\n\nexport interface AgentProps {\n    /**\n     * Proxy URL for browser-safe API calls (recommended for frontend apps)\n     * @example \"/api/inference/proxy\"\n     */\n    proxyUrl?: string;\n    /** Direct API key (use only in secure environments, not recommended for browsers) */\n    apiKey?: string;\n    /** Agent configuration */\n    config: AgentOptions;\n    /** Optional name for ad-hoc agents (used for deduplication and display) */\n    name?: string;\n    /** Optional existing chat ID */\n    chatId?: string;\n    /** Additional CSS classes */\n    className?: string;\n    /** Compact mode (no header) */\n    compact?: boolean;\n    /** Allow file attachments (default: true) */\n    allowFiles?: boolean;\n    /** Allow image attachments (default: true) */\n    allowImages?: boolean;\n    /** Callback when chat is created */\n    onChatCreated?: (chatId: string) => void;\n}\n\nexport interface ChatMessagesProps {\n    children: (props: { messages: ChatMessageDTO[] }) => ReactNode;\n    className?: string;\n    scrollToTopPadding?: boolean;\n}\n\nexport interface ChatInputProps {\n    placeholder?: string;\n    className?: string;\n    /** @deprecated Use allowFiles and allowImages instead */\n    allowAttachments?: boolean;\n    /** Allow file attachments (default: true) */\n    allowFiles?: boolean;\n    /** Allow image attachments (default: true) */\n    allowImages?: boolean;\n    onFilesChange?: (files: File[]) => void;\n}\n\nexport interface MessageBubbleProps {\n    message: ChatMessageDTO;\n    children?: ReactNode;\n    className?: string;\n}\n\nexport interface MessageContentProps {\n    message: ChatMessageDTO;\n    className?: string;\n    truncate?: boolean;\n}\n\nexport interface ToolInvocationProps {\n    invocation: ToolInvocationDTO;\n    className?: string;\n    defaultOpen?: boolean;\n}\n\nexport interface ToolInvocationsProps {\n    message: ChatMessageDTO;\n    className?: string;\n}\n\nexport interface MessageReasoningProps {\n    reasoning: string;\n    isReasoning?: boolean;\n    className?: string;\n}\n\nexport interface ChatContainerProps {\n    children: ReactNode;\n    className?: string;\n}\n\n// =============================================================================\n// Client Tools\n// =============================================================================\n\nexport type ClientToolHandlerFn = (args: Record<string, unknown>) => Promise<string>;\n\nexport interface ClientTool {\n    schema: AgentTool;\n    handler: ClientToolHandlerFn;\n}\n\nexport function isClientTool(tool: AgentTool | ClientTool): tool is ClientTool {\n    return 'handler' in tool && 'schema' in tool;\n}\n\nexport function extractToolSchemas(tools: (AgentTool | ClientTool)[]): AgentTool[] {\n    return tools.map(t => isClientTool(t) ? t.schema : t);\n}\n\nexport function extractClientToolHandlers(\n    tools: (AgentTool | ClientTool)[]\n): Map<string, ClientToolHandlerFn> {\n    const handlers = new Map<string, ClientToolHandlerFn>();\n    for (const tool of tools) {\n        if (isClientTool(tool)) {\n            handlers.set(tool.schema.name, tool.handler);\n        }\n    }\n    return handlers;\n}\n\n// =============================================================================\n// Constants (re-exported from SDK)\n// =============================================================================\n\nexport {\n    ChatMessageRoleUser,\n    ChatMessageRoleAssistant,\n    ChatMessageRoleTool,\n    ChatMessageRoleSystem,\n    ChatMessageContentTypeText,\n    ChatMessageContentTypeReasoning,\n    ChatMessageContentTypeImage,\n    ChatMessageContentTypeFile,\n    ChatMessageStatusReady,\n    ChatMessageStatusFailed,\n    ChatMessageStatusCancelled,\n    ToolTypeClient,\n    ToolTypeApp,\n    ToolInvocationStatusPending,\n    ToolInvocationStatusInProgress,\n    ToolInvocationStatusAwaitingInput,\n    ToolInvocationStatusAwaitingApproval,\n    ToolInvocationStatusCompleted,\n    ToolInvocationStatusFailed,\n    ToolInvocationStatusCancelled,\n} from '@inferencesh/sdk';\n\n// =============================================================================\n// Widget Types (for tool output rendering)\n// =============================================================================\n\nexport const WidgetTypeUI = 'ui';\nexport const WidgetTypeHTML = 'html';\n\nexport interface WidgetNode {\n    type: string;\n    // Text/title/caption nodes\n    value?: string;\n    variant?: string;\n    size?: string;\n    weight?: string;\n    color?: string;\n    // Label\n    fieldName?: string;\n    // Image\n    src?: string;\n    alt?: string;\n    height?: number | string;\n    width?: number | string;\n    // Badge/Icon\n    label?: string;\n    iconName?: string;\n    // Button - actions attached directly\n    /** @deprecated Use onClickAction instead */\n    action?: WidgetAction;\n    /** Action triggered when element is clicked */\n    onClickAction?: WidgetAction;\n    disabled?: boolean;\n    // Input/Textarea\n    name?: string;\n    placeholder?: string;\n    defaultValue?: string;\n    required?: boolean;\n    rows?: number;\n    /** Action triggered when input value changes */\n    onChangeAction?: WidgetAction;\n    // Select/Radio\n    options?: { value: string; label: string }[];\n    // Checkbox\n    defaultChecked?: boolean;\n    /** Action triggered when checkbox is toggled */\n    onCheckedChangeAction?: WidgetAction;\n    // Layout\n    children?: WidgetNode[];\n    gap?: number;\n    align?: string;\n    justify?: string;\n    direction?: string;\n    padding?: number;\n    background?: string | { light?: string; dark?: string };\n    radius?: string;\n    /** Minimum height in pixels or CSS value */\n    minHeight?: number | string;\n    /** Maximum height in pixels or CSS value */\n    maxHeight?: number | string;\n    /** Minimum width in pixels or CSS value */\n    minWidth?: number | string;\n    /** Maximum width in pixels or CSS value */\n    maxWidth?: number | string;\n    /** Aspect ratio (e.g., \"16/9\", \"4/3\", \"1/1\") */\n    aspectRatio?: string;\n    // Spacer/Divider\n    minSize?: number;\n    spacing?: number;\n    // Form\n    onSubmitAction?: WidgetAction;\n    // Card\n    /** Treat Card as Form, collecting child inputs on confirm */\n    asForm?: boolean;\n    /** Card confirm action (used when asForm=true) */\n    confirmAction?: WidgetAction;\n}\n\n/**\n * Widget action configuration - attached directly to interactive elements\n * @example\n * { type: \"submit\", payload: { id: 123 }, handler: \"server\", loadingBehavior: \"self\" }\n */\nexport interface WidgetAction {\n    /** Action type identifier */\n    type: string;\n    /** Optional payload data */\n    payload?: Record<string, unknown>;\n    /** Handler location: 'server' (default) sends to backend, 'client' calls local callback */\n    handler?: 'server' | 'client';\n    /** Loading behavior when action is triggered */\n    loadingBehavior?: 'auto' | 'self' | 'container' | 'none';\n}\n\nexport interface WidgetFormData {\n    [key: string]: string | boolean | undefined;\n}\n\n/**\n * Widget structure\n * Note: `actions` array (card footer buttons) is deprecated.\n * Use `onClickAction` on buttons/elements instead.\n */\nexport interface Widget {\n    type: string;\n    title?: string;\n    html?: string;\n    content?: string;\n    children?: WidgetNode[];\n    /** @deprecated - Use onClickAction on individual elements instead */\n    actions?: { label: string; variant?: string; action: WidgetAction }[];\n    [key: string]: unknown;\n}\n\n// =============================================================================\n// Tool Finish Types\n// =============================================================================\n\nexport interface ToolFinish {\n    status: string;\n    result?: unknown;\n    error?: string;\n}\n\nexport const ToolFinishStatusSucceeded = 'succeeded';\nexport const ToolFinishStatusFailed = 'failed';\nexport const ToolFinishStatusCancelled = 'cancelled';\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Check if a chat message status is terminal (generation complete)\n */\nexport function isTerminalChatMessageStatus(status: string | undefined): boolean {\n    return status === 'ready' || status === 'failed' || status === 'cancelled';\n}\n",
      "type": "registry:lib",
      "target": "components/agent/types.ts"
    },
    {
      "path": "registry/blocks/agent/hooks/use-agent.ts",
      "content": "/**\n * Agent Chat Hooks\n * \n * Public hooks for accessing chat state and actions.\n */\n\nimport { useContext } from 'react';\nimport { AgentContext } from '@/components/agent/context';\nimport type { AgentState, AgentActions, ChatMessageDTO } from '@/components/agent/types';\n\n/**\n * Hook to access chat state\n */\nexport function useAgent(): AgentState {\n    const context = useContext(AgentContext);\n\n    if (!context) {\n        throw new Error(\n            'useAgent must be used within an AgentProvider. ' +\n            'Wrap your component tree with <AgentProvider>.'\n        );\n    }\n\n    return context.state;\n}\n\n/**\n * Hook to access chat actions\n */\nexport function useAgentActions(): AgentActions {\n    const context = useContext(AgentContext);\n\n    if (!context) {\n        throw new Error(\n            'useAgentActions must be used within an AgentProvider. ' +\n            'Wrap your component tree with <AgentProvider>.'\n        );\n    }\n\n    return context.actions;\n}\n\n/**\n * Hook to access a specific message by ID\n */\nexport function useMessage(messageId: string): ChatMessageDTO | undefined {\n    const { messages } = useAgent();\n    return messages.find((m) => m.id === messageId);\n}\n\n/**\n * Hook to access both state and actions\n */\nexport function useAgentContext(): { state: AgentState; actions: AgentActions } {\n    const context = useContext(AgentContext);\n\n    if (!context) {\n        throw new Error(\n            'useAgentContext must be used within an AgentProvider. ' +\n            'Wrap your component tree with <AgentProvider>.'\n        );\n    }\n\n    return context;\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-agent.ts"
    },
    {
      "path": "registry/blocks/agent/internal/reducer.ts",
      "content": "/**\n * Agent Chat Internal Reducer\n * \n * Pure reducer for chat state management.\n */\n\nimport type { ChatDTO, ChatMessageDTO, AgentState, AgentUIStatus } from '@/components/agent/types';\n\n// =============================================================================\n// Action Types\n// =============================================================================\n\nexport type ChatAction =\n    | { type: 'SET_CHAT_ID'; payload: string | null }\n    | { type: 'SET_CHAT'; payload: ChatDTO | null }\n    | { type: 'SET_MESSAGES'; payload: ChatMessageDTO[] }\n    | { type: 'UPDATE_MESSAGE'; payload: ChatMessageDTO }\n    | { type: 'ADD_MESSAGE'; payload: ChatMessageDTO }\n    | { type: 'SET_STATUS'; payload: AgentUIStatus }\n    | { type: 'SET_IS_GENERATING'; payload: boolean }\n    | { type: 'SET_ERROR'; payload: string | undefined }\n    | { type: 'RESET' };\n\n// =============================================================================\n// Initial State\n// =============================================================================\n\nexport const initialState: AgentState = {\n    chatId: null,\n    messages: [],\n    status: 'idle',\n    isGenerating: false,\n    error: undefined,\n    chat: null,\n};\n\n// =============================================================================\n// Reducer\n// =============================================================================\n\nexport function chatReducer(state: AgentState, action: ChatAction): AgentState {\n    switch (action.type) {\n        case 'SET_CHAT_ID':\n            return { ...state, chatId: action.payload };\n\n        case 'SET_CHAT': {\n            const chat = action.payload;\n            if (!chat) {\n                return { ...state, chat: null, messages: [], isGenerating: false, status: 'idle' };\n            }\n            // Populate messages from chat.chat_messages (initial load and refreshes)\n            const messages = [...(chat.chat_messages || [])].sort((a, b) => a.order - b.order);\n            const isGenerating = chat.status === 'busy';\n            const status = isGenerating ? 'streaming' : 'idle';\n            return { ...state, chat, messages, isGenerating, status };\n        }\n\n        case 'SET_MESSAGES':\n            return { ...state, messages: action.payload };\n\n        case 'UPDATE_MESSAGE': {\n            const message = action.payload;\n            const existingIndex = state.messages.findIndex((m) => m.id === message.id);\n            let newMessages: ChatMessageDTO[];\n            if (existingIndex !== -1) {\n                newMessages = [...state.messages];\n                newMessages[existingIndex] = message;\n            } else {\n                newMessages = [...state.messages, message].sort((a, b) => a.order - b.order);\n            }\n            return { ...state, messages: newMessages };\n        }\n\n        case 'ADD_MESSAGE':\n            return {\n                ...state,\n                messages: [...state.messages, action.payload].sort((a, b) => a.order - b.order),\n            };\n\n        case 'SET_STATUS':\n            return {\n                ...state,\n                status: action.payload,\n                isGenerating: action.payload === 'streaming' || action.payload === 'connecting',\n            };\n\n        case 'SET_IS_GENERATING':\n            return { ...state, isGenerating: action.payload };\n\n        case 'SET_ERROR':\n            return { ...state, error: action.payload };\n\n        case 'RESET':\n            return initialState;\n\n        default:\n            return state;\n    }\n}\n",
      "type": "registry:lib",
      "target": "components/agent/lib/reducer.ts"
    },
    {
      "path": "registry/blocks/agent/internal/actions.ts",
      "content": "/**\n * Agent Chat Actions\n * \n * Action creators using the Inference SDK Agent for all API operations.\n */\n\nimport type { Dispatch } from 'react';\nimport type { Agent, Inference, ChatDTO, ChatMessageDTO } from '@inferencesh/sdk';\nimport { ToolTypeClient, ToolInvocationStatusAwaitingInput } from '@inferencesh/sdk';\nimport type {\n    AgentOptions,\n    AgentUIStatus,\n    AgentActions,\n    ClientToolHandlerFn,\n} from '@/components/agent/types';\nimport {\n    isAdHocConfig,\n    extractClientToolHandlers,\n    extractToolSchemas,\n} from '@/components/agent/types';\nimport type { ChatAction } from '@/components/agent/lib/reducer';\n\n// =============================================================================\n// Track dispatched client tool invocations to prevent duplicates\n// =============================================================================\n\nconst dispatchedToolInvocations = new Set<string>();\n\n// =============================================================================\n// Actions Context Interface\n// =============================================================================\n\nexport interface ActionsContext {\n    dispatch: Dispatch<ChatAction>;\n    getClient: () => Inference;\n    getAgent: () => Agent | null;\n    setAgent: (agent: Agent | null) => void;\n    getConfig: () => AgentOptions | null;\n    getAgentName: () => string | undefined;\n    getChatId: () => string | null;\n    getClientToolHandlers: () => Map<string, ClientToolHandlerFn>;\n    callbacks: {\n        onChatCreated?: (chatId: string) => void;\n        onStatusChange?: (status: AgentUIStatus) => void;\n        onError?: (error: Error) => void;\n    };\n}\n\n// =============================================================================\n// Action Creators\n// =============================================================================\n\nexport interface InternalActions {\n    setChatId: (newChatId: string | null) => void;\n    stopStream: () => void;\n}\n\nexport interface ActionsResult {\n    publicActions: AgentActions;\n    internalActions: InternalActions;\n}\n\nexport function createActions(ctx: ActionsContext): ActionsResult {\n    const { dispatch, getClient, getAgent, setAgent, getConfig, getAgentName, getChatId, getClientToolHandlers, callbacks } = ctx;\n\n    // =========================================================================\n    // Internal helpers\n    // =========================================================================\n\n    const setChat = (chat: ChatDTO | null) => {\n        dispatch({ type: 'SET_CHAT', payload: chat });\n        if (chat) {\n            // CRITICAL: Set chatId from the chat so streaming updates aren't filtered\n            // The updateMessage function filters messages where chat_id !== getChatId()\n            // Without this, all streaming updates are discarded because chatId is null\n            const currentChatId = getChatId();\n            if (!currentChatId && chat.id) {\n                dispatch({ type: 'SET_CHAT_ID', payload: chat.id });\n                callbacks.onChatCreated?.(chat.id);\n            }\n\n            const status = chat.status === 'busy' ? 'streaming' : 'idle';\n            callbacks.onStatusChange?.(status);\n        }\n    };\n\n    const updateMessage = (message: ChatMessageDTO) => {\n        const chatId = getChatId();\n        if (message.chat_id !== chatId) return;\n\n        dispatch({ type: 'UPDATE_MESSAGE', payload: message });\n\n        // Check for client tool invocations that need execution\n        const clientToolHandlers = getClientToolHandlers();\n        if (message.tool_invocations && chatId && clientToolHandlers.size > 0) {\n            for (const invocation of message.tool_invocations) {\n                if (\n                    invocation.type === ToolTypeClient &&\n                    invocation.status === ToolInvocationStatusAwaitingInput\n                ) {\n                    // Skip if already dispatched\n                    if (dispatchedToolInvocations.has(invocation.id)) {\n                        continue;\n                    }\n                    dispatchedToolInvocations.add(invocation.id);\n\n                    const functionName = invocation.function?.name || '';\n                    const handler = clientToolHandlers.get(functionName);\n\n                    if (!handler) {\n                        console.warn(`[Agent] No handler for client tool: ${functionName}`);\n                        const agent = getAgent();\n                        agent?.submitToolResult(invocation.id, JSON.stringify({\n                            error: `No handler registered for tool: ${functionName}`\n                        }));\n                        continue;\n                    }\n\n                    // Execute the handler\n                    const args = invocation.function?.arguments || {};\n                    handler(args)\n                        .then((result) => {\n                            const agent = getAgent();\n                            agent?.submitToolResult(invocation.id, result);\n                        })\n                        .catch((error) => {\n                            console.error(`[Agent] Client tool ${functionName} error:`, error);\n                            const agent = getAgent();\n                            agent?.submitToolResult(invocation.id, JSON.stringify({\n                                error: String(error)\n                            }));\n                        });\n                }\n            }\n        }\n    };\n\n    const createAgent = (): Agent | null => {\n        const config = getConfig();\n        const agentName = getAgentName();\n        const client = getClient();\n        if (!config) return null;\n\n        if (isAdHocConfig(config)) {\n            // Extract just schemas (strip handlers)\n            const toolSchemas = config.tools ? extractToolSchemas(config.tools) : undefined;\n            return client.agent({\n                ...config,\n                tools: toolSchemas,\n            }, { name: agentName });\n        } else {\n            return client.agent(config.agent);\n        }\n    };\n\n    const stopStream = () => {\n        const agent = getAgent();\n        agent?.disconnect();\n        dispatch({ type: 'SET_STATUS', payload: 'idle' });\n        dispatch({ type: 'SET_IS_GENERATING', payload: false });\n        callbacks.onStatusChange?.('idle');\n    };\n\n    // =========================================================================\n    // Public Actions\n    // =========================================================================\n\n    const publicActions: AgentActions = {\n        sendMessage: async (text: string, files?: (Blob | import('@inferencesh/sdk').File)[]) => {\n            const config = getConfig();\n            if (!config) {\n                console.error('[Agent] No agent config provided');\n                return;\n            }\n\n            const trimmedText = text.trim();\n            if (!trimmedText) return;\n\n            // Get or create agent\n            let agent = getAgent();\n            if (!agent) {\n                agent = createAgent();\n                if (!agent) {\n                    console.error('[Agent] Failed to create agent');\n                    return;\n                }\n                setAgent(agent);\n            }\n\n            // Update status\n            dispatch({ type: 'SET_STATUS', payload: 'streaming' });\n            dispatch({ type: 'SET_ERROR', payload: undefined });\n            callbacks.onStatusChange?.('streaming');\n\n            try {\n                // Pass files directly - SDK detects FileDTO by uri property, uploads Blobs\n                const { assistantMessage } = await agent.sendMessage(trimmedText, {\n                    files: files,\n                });\n\n                // Get the chatId\n                const newChatId = assistantMessage.chat_id;\n                if (newChatId && newChatId !== getChatId()) {\n                    dispatch({ type: 'SET_CHAT_ID', payload: newChatId });\n                    callbacks.onChatCreated?.(newChatId);\n                }\n\n                // Start streaming (like frontend/app's streamChat pattern)\n                agent.startStreaming({\n                    onMessage: (message: ChatMessageDTO) => {\n                        updateMessage(message);\n                    },\n                    onChat: (chat: ChatDTO) => {\n                        setChat(chat);\n                    },\n                });\n\n                // Fetch the full chat to get complete messages\n                // This is the key step that frontend/app does in streamChat\n                const currentChatId = getChatId() || newChatId;\n                if (currentChatId) {\n                    const fullChat = await agent.getChat(currentChatId);\n                    if (fullChat) {\n                        setChat(fullChat);\n                    }\n                }\n\n            } catch (error) {\n                console.error('[Agent] Failed to send message:', error);\n                const err = error instanceof Error ? error : new Error('Failed to send message');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n            }\n        },\n\n        stopGeneration: () => {\n            const agent = getAgent();\n            stopStream();\n            agent?.stopChat();\n        },\n\n        reset: () => {\n            const agent = getAgent();\n            agent?.reset();\n            setAgent(null);\n            dispatchedToolInvocations.clear();\n            dispatch({ type: 'RESET' });\n        },\n\n        clearError: () => {\n            dispatch({ type: 'SET_ERROR', payload: undefined });\n            dispatch({ type: 'SET_STATUS', payload: 'idle' });\n        },\n\n        submitToolResult: async (toolInvocationId: string, result: string) => {\n            try {\n                const agent = getAgent();\n                if (!agent) throw new Error('No active agent');\n                await agent.submitToolResult(toolInvocationId, result);\n            } catch (error) {\n                console.error('[Agent] Failed to submit tool result:', error);\n                const err = error instanceof Error ? error : new Error('Failed to submit tool result');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n\n        approveTool: async (toolInvocationId: string) => {\n            try {\n                const client = getClient();\n                await client._request('post', `/tools/${toolInvocationId}/invoke`);\n            } catch (error) {\n                console.error('[Agent] Failed to approve tool:', error);\n                const err = error instanceof Error ? error : new Error('Failed to approve tool');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n\n        rejectTool: async (toolInvocationId: string, reason?: string) => {\n            try {\n                const client = getClient();\n                await client._request('post', `/tools/${toolInvocationId}/reject`, { data: { reason } });\n            } catch (error) {\n                console.error('[Agent] Failed to reject tool:', error);\n                const err = error instanceof Error ? error : new Error('Failed to reject tool');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n\n        alwaysAllowTool: async (toolInvocationId: string, toolName: string) => {\n            const chatId = getChatId();\n            if (!chatId) {\n                console.error('[Agent] Cannot always-allow tool without a chatId');\n                return;\n            }\n\n            try {\n                const client = getClient();\n                await client._request('post', `/chats/${chatId}/tools/${toolInvocationId}/always-allow`, {\n                    data: { tool_name: toolName }\n                });\n            } catch (error) {\n                console.error('[Agent] Failed to always-allow tool:', error);\n                const err = error instanceof Error ? error : new Error('Failed to always-allow tool');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n    };\n\n    const internalActions: InternalActions = {\n        stopStream,\n        setChatId: (newChatId: string | null) => {\n            const currentChatId = getChatId();\n            if (newChatId === currentChatId) return;\n\n            if (!newChatId) {\n                stopStream();\n                dispatchedToolInvocations.clear();\n                dispatch({ type: 'RESET' });\n                return;\n            }\n\n            dispatch({ type: 'SET_CHAT_ID', payload: newChatId });\n        },\n    };\n\n    return { publicActions, internalActions };\n}\n\n// =============================================================================\n// Helper: Extract client tool handlers from config\n// =============================================================================\n\nexport function getClientToolHandlers(config: AgentOptions | null): Map<string, ClientToolHandlerFn> {\n    if (!config || !isAdHocConfig(config) || !config.tools) {\n        return new Map();\n    }\n    return extractClientToolHandlers(config.tools);\n}\n",
      "type": "registry:lib",
      "target": "components/agent/lib/actions.ts"
    },
    {
      "path": "registry/blocks/agent/lib/tool-builder.ts",
      "content": "/**\n * Tool Builder - Fluent API for defining tools\n * \n * A DX-friendly way to define tools with type inference.\n * \n * ## Tool Types\n * \n * | Type | Runs On | Has Handler | Example |\n * |------|---------|-------------|---------|\n * | `tool()` | Browser | Yes | DOM manipulation, localStorage |\n * | `hookTool()` | Browser | Yes (via hook) | useGeolocation, useAuth |\n * | `appTool()` | Server | No | Image generation, code execution |\n * | `agentTool()` | Server | No | Sub-agent delegation |\n * | `webhookTool()` | External | No | Third-party APIs |\n * \n * @example Client tool\n * ```typescript\n * const scanUI = tool('scan_ui')\n *   .describe('Scans the DOM')\n *   .handler(async () => { ... });\n * ```\n * \n * @example App tool with HIL\n * ```typescript\n * const deploy = appTool('deploy', 'infsh/deploy-app@abc123')\n *   .describe('Deploys to production')\n *   .requireApproval()  // Human must approve\n *   .param('env', enumOf(['staging', 'prod']))\n *   .build();\n * ```\n * \n * @example Internal tools config\n * ```typescript\n * const config = {\n *   core_app_ref: '...',\n *   internal_tools: internalTools()\n *     .plan()\n *     .memory()\n *     .finish()\n *     .build(),\n * };\n * ```\n */\n\nimport {\n  ToolTypeClient,\n  ToolTypeApp,\n  ToolTypeAgent,\n  ToolTypeHook,\n  type AgentTool,\n  type InternalToolsConfig,\n} from '@inferencesh/sdk';\nimport type { ClientTool, ClientToolHandlerFn } from '@/components/agent/types';\n\n// =============================================================================\n// Schema Types\n// =============================================================================\n\ntype JsonSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array';\n\ninterface BaseSchema {\n  type: JsonSchemaType;\n  description?: string;\n  optional?: boolean;\n}\n\ninterface StringSchema extends BaseSchema {\n  type: 'string';\n  enum?: string[];\n}\n\ninterface NumberSchema extends BaseSchema {\n  type: 'number' | 'integer';\n  minimum?: number;\n  maximum?: number;\n}\n\ninterface BooleanSchema extends BaseSchema {\n  type: 'boolean';\n}\n\ninterface ObjectSchema extends BaseSchema {\n  type: 'object';\n  properties: Record<string, ParamSchema>;\n}\n\ninterface ArraySchema extends BaseSchema {\n  type: 'array';\n  items: ParamSchema;\n}\n\ntype ParamSchema = StringSchema | NumberSchema | BooleanSchema | ObjectSchema | ArraySchema;\n\n// =============================================================================\n// Type Inference\n// =============================================================================\n\ntype InferType<T extends ParamSchema> =\n  T extends StringSchema\n  ? T['enum'] extends readonly string[]\n  ? T['enum'][number]\n  : string\n  : T extends NumberSchema\n  ? number\n  : T extends BooleanSchema\n  ? boolean\n  : T extends ObjectSchema\n  ? { [K in keyof T['properties']as T['properties'][K]['optional'] extends true ? never : K]: InferType<T['properties'][K]> }\n  & { [K in keyof T['properties']as T['properties'][K]['optional'] extends true ? K : never]?: InferType<T['properties'][K]> }\n  : T extends ArraySchema\n  ? InferType<T['items']>[]\n  : unknown;\n\ntype InferParams<T extends Record<string, ParamSchema>> = {\n  [K in keyof T as T[K]['optional'] extends true ? never : K]: InferType<T[K]>;\n} & {\n  [K in keyof T as T[K]['optional'] extends true ? K : never]?: InferType<T[K]>;\n};\n\n// =============================================================================\n// Schema Builders\n// =============================================================================\n\n/** String parameter */\nexport function string(description?: string): StringSchema {\n  return { type: 'string', description };\n}\n\n/** String enum parameter */\nexport function enumOf<T extends readonly string[]>(values: T, description?: string): StringSchema & { enum: T } {\n  return { type: 'string', enum: values as unknown as string[], description } as StringSchema & { enum: T };\n}\n\n/** Number parameter */\nexport function number(description?: string): NumberSchema {\n  return { type: 'number', description };\n}\n\n/** Integer parameter */\nexport function integer(description?: string): NumberSchema {\n  return { type: 'integer', description };\n}\n\n/** Boolean parameter */\nexport function boolean(description?: string): BooleanSchema {\n  return { type: 'boolean', description };\n}\n\n/** Object with nested properties */\nexport function object<T extends Record<string, ParamSchema>>(\n  properties: T,\n  description?: string\n): ObjectSchema & { properties: T } {\n  return { type: 'object', properties, description } as ObjectSchema & { properties: T };\n}\n\n/** Array parameter */\nexport function array<T extends ParamSchema>(items: T, description?: string): ArraySchema & { items: T } {\n  return { type: 'array', items, description } as ArraySchema & { items: T };\n}\n\n/** Make a schema optional */\nexport function optional<T extends ParamSchema>(schema: T): T & { optional: true } {\n  return { ...schema, optional: true } as T & { optional: true };\n}\n\n// =============================================================================\n// JSON Schema Generator\n// =============================================================================\n\nfunction toJsonSchema(schema: ParamSchema): Record<string, unknown> {\n  const base: Record<string, unknown> = { type: schema.type };\n  if (schema.description) base.description = schema.description;\n\n  if (schema.type === 'string' && 'enum' in schema && schema.enum) {\n    base.enum = schema.enum;\n  }\n\n  if ((schema.type === 'number' || schema.type === 'integer')) {\n    const numSchema = schema as NumberSchema;\n    if (numSchema.minimum !== undefined) base.minimum = numSchema.minimum;\n    if (numSchema.maximum !== undefined) base.maximum = numSchema.maximum;\n  }\n\n  if (schema.type === 'object') {\n    const objSchema = schema as ObjectSchema;\n    const properties: Record<string, unknown> = {};\n    const required: string[] = [];\n    for (const [key, propSchema] of Object.entries(objSchema.properties)) {\n      properties[key] = toJsonSchema(propSchema);\n      if (!propSchema.optional) required.push(key);\n    }\n    base.properties = properties;\n    if (required.length > 0) base.required = required;\n  }\n\n  if (schema.type === 'array') {\n    base.items = toJsonSchema((schema as ArraySchema).items);\n  }\n\n  return base;\n}\n\nfunction paramsToJsonSchema(params: Record<string, ParamSchema>): Record<string, unknown> {\n  const properties: Record<string, unknown> = {};\n  const required: string[] = [];\n  for (const [key, schema] of Object.entries(params)) {\n    properties[key] = toJsonSchema(schema);\n    if (!schema.optional) required.push(key);\n  }\n  return { type: 'object', properties, required };\n}\n\n// =============================================================================\n// Base Builder State\n// =============================================================================\n\ninterface BaseToolState<TParams extends Record<string, ParamSchema>> {\n  name: string;\n  displayName?: string;\n  description: string;\n  params: TParams;\n  requireApproval: boolean;\n}\n\n// =============================================================================\n// CLIENT TOOL BUILDER (runs in browser, has handler)\n// =============================================================================\n\nclass ClientToolBuilder<TParams extends Record<string, ParamSchema> = Record<string, never>> {\n  private state: BaseToolState<TParams>;\n\n  constructor(name: string) {\n    this.state = { name, description: '', params: {} as TParams, requireApproval: false };\n  }\n\n  /** Set description */\n  describe(description: string): this {\n    this.state.description = description;\n    return this;\n  }\n\n  /** Set display name */\n  displayName(name: string): this {\n    this.state.displayName = name;\n    return this;\n  }\n\n  /** Require human approval before execution (HIL) */\n  requireApproval(): this {\n    this.state.requireApproval = true;\n    return this;\n  }\n\n  /** Alias for requireApproval */\n  hil(): this {\n    return this.requireApproval();\n  }\n\n  /** Add a parameter */\n  param<K extends string, S extends ParamSchema>(\n    name: K,\n    schema: S\n  ): ClientToolBuilder<TParams & Record<K, S>> {\n    const newBuilder = new ClientToolBuilder<TParams & Record<K, S>>(this.state.name);\n    newBuilder.state = {\n      ...this.state,\n      params: { ...this.state.params, [name]: schema } as TParams & Record<K, S>,\n    };\n    return newBuilder;\n  }\n\n  /** Define handler and build the tool */\n  handler(fn: (args: InferParams<TParams>) => Promise<string> | string): ClientTool {\n    return {\n      schema: {\n        name: this.state.name,\n        display_name: this.state.displayName || this.state.name,\n        description: this.state.description,\n        type: ToolTypeClient,\n        require_approval: this.state.requireApproval || undefined,\n        client: { input_schema: paramsToJsonSchema(this.state.params) },\n      },\n      handler: async (args) => fn(args as InferParams<TParams>),\n    };\n  }\n}\n\n/**\n * Create a client tool (runs in browser)\n * \n * @example\n * ```typescript\n * const copyToClipboard = tool('copy')\n *   .describe('Copies text to clipboard')\n *   .param('text', string('Text to copy'))\n *   .handler(async ({ text }) => {\n *     await navigator.clipboard.writeText(text);\n *     return JSON.stringify({ success: true });\n *   });\n * ```\n */\nexport function tool(name: string): ClientToolBuilder {\n  return new ClientToolBuilder(name);\n}\n\n// =============================================================================\n// HOOK TOOL BUILDER (runs in browser, uses React hooks)\n// =============================================================================\n\nexport interface HookTool {\n  schema: AgentTool;\n  useHandler: () => ClientToolHandlerFn;\n}\n\nclass HookToolBuilder<TParams extends Record<string, ParamSchema> = Record<string, never>> {\n  private state: BaseToolState<TParams>;\n  private hookFactory: () => ClientToolHandlerFn;\n\n  constructor(name: string, hookFactory: () => ClientToolHandlerFn) {\n    this.state = { name, description: '', params: {} as TParams, requireApproval: false };\n    this.hookFactory = hookFactory;\n  }\n\n  describe(description: string): this {\n    this.state.description = description;\n    return this;\n  }\n\n  displayName(name: string): this {\n    this.state.displayName = name;\n    return this;\n  }\n\n  requireApproval(): this {\n    this.state.requireApproval = true;\n    return this;\n  }\n\n  hil(): this {\n    return this.requireApproval();\n  }\n\n  param<K extends string, S extends ParamSchema>(\n    name: K,\n    schema: S\n  ): HookToolBuilder<TParams & Record<K, S>> {\n    const newBuilder = new HookToolBuilder<TParams & Record<K, S>>(this.state.name, this.hookFactory);\n    newBuilder.state = {\n      ...this.state,\n      params: { ...this.state.params, [name]: schema } as TParams & Record<K, S>,\n    };\n    return newBuilder;\n  }\n\n  /** Build the hook tool */\n  build(): HookTool {\n    return {\n      schema: {\n        name: this.state.name,\n        display_name: this.state.displayName || this.state.name,\n        description: this.state.description,\n        type: ToolTypeClient,\n        require_approval: this.state.requireApproval || undefined,\n        client: { input_schema: paramsToJsonSchema(this.state.params) },\n      },\n      useHandler: this.hookFactory,\n    };\n  }\n}\n\n/**\n * Create a hook-based tool (uses React hooks)\n * \n * @example\n * ```typescript\n * const authTool = hookTool('get_user', () => {\n *   const { user } = useAuth();\n *   return async () => JSON.stringify(user);\n * })\n *   .describe('Gets current user info')\n *   .build();\n * ```\n */\nexport function hookTool(name: string, useHandler: () => ClientToolHandlerFn): HookToolBuilder {\n  return new HookToolBuilder(name, useHandler);\n}\n\n/** Convert HookTools to ClientTools (call in component) */\nexport function useHookTools(hookTools: HookTool[]): ClientTool[] {\n  return hookTools.map(ht => ({ schema: ht.schema, handler: ht.useHandler() }));\n}\n\n// =============================================================================\n// APP TOOL BUILDER (runs on server, calls another app)\n// =============================================================================\n\nclass AppToolBuilder<TParams extends Record<string, ParamSchema> = Record<string, never>> {\n  private state: BaseToolState<TParams> & { appRef: string };\n\n  constructor(name: string, appRef: string) {\n    this.state = { name, appRef, description: '', params: {} as TParams, requireApproval: false };\n  }\n\n  describe(description: string): this {\n    this.state.description = description;\n    return this;\n  }\n\n  displayName(name: string): this {\n    this.state.displayName = name;\n    return this;\n  }\n\n  requireApproval(): this {\n    this.state.requireApproval = true;\n    return this;\n  }\n\n  hil(): this {\n    return this.requireApproval();\n  }\n\n  param<K extends string, S extends ParamSchema>(\n    name: K,\n    schema: S\n  ): AppToolBuilder<TParams & Record<K, S>> {\n    const newBuilder = new AppToolBuilder<TParams & Record<K, S>>(this.state.name, this.state.appRef);\n    newBuilder.state = {\n      ...this.state,\n      params: { ...this.state.params, [name]: schema } as TParams & Record<K, S>,\n    };\n    return newBuilder;\n  }\n\n  /** Build the app tool schema */\n  build(): AgentTool {\n    return {\n      name: this.state.name,\n      display_name: this.state.displayName || this.state.name,\n      description: this.state.description,\n      type: ToolTypeApp,\n      require_approval: this.state.requireApproval || undefined,\n      app: {\n        ref: this.state.appRef,\n      },\n    };\n  }\n}\n\n/**\n * Create an app tool (calls another inference app on server)\n * \n * @example\n * ```typescript\n * const imageGen = appTool('generate_image', 'infsh/flux-schnell@abc123')\n *   .describe('Generates an image from a prompt')\n *   .param('prompt', string('Image description'))\n *   .requireApproval()  // Costs credits, require approval\n *   .build();\n * ```\n */\nexport function appTool(name: string, appRef: string): AppToolBuilder {\n  return new AppToolBuilder(name, appRef);\n}\n\n// =============================================================================\n// AGENT TOOL BUILDER (runs on server, delegates to sub-agent)\n// =============================================================================\n\nclass AgentToolBuilder<TParams extends Record<string, ParamSchema> = Record<string, never>> {\n  private state: BaseToolState<TParams> & { agentRef: string };\n\n  constructor(name: string, agentRef: string) {\n    this.state = { name, agentRef, description: '', params: {} as TParams, requireApproval: false };\n  }\n\n  describe(description: string): this {\n    this.state.description = description;\n    return this;\n  }\n\n  displayName(name: string): this {\n    this.state.displayName = name;\n    return this;\n  }\n\n  requireApproval(): this {\n    this.state.requireApproval = true;\n    return this;\n  }\n\n  hil(): this {\n    return this.requireApproval();\n  }\n\n  param<K extends string, S extends ParamSchema>(\n    name: K,\n    schema: S\n  ): AgentToolBuilder<TParams & Record<K, S>> {\n    const newBuilder = new AgentToolBuilder<TParams & Record<K, S>>(this.state.name, this.state.agentRef);\n    newBuilder.state = {\n      ...this.state,\n      params: { ...this.state.params, [name]: schema } as TParams & Record<K, S>,\n    };\n    return newBuilder;\n  }\n\n  /** Build the agent tool schema */\n  build(): AgentTool {\n    return {\n      name: this.state.name,\n      display_name: this.state.displayName || this.state.name,\n      description: this.state.description,\n      type: ToolTypeAgent,\n      require_approval: this.state.requireApproval || undefined,\n      agent: {\n        ref: this.state.agentRef,\n      },\n    };\n  }\n}\n\n/**\n * Create a sub-agent tool (delegates to another agent on server)\n * \n * @example\n * ```typescript\n * const codeReviewer = agentTool('review_code', 'infsh/code-reviewer@xyz789')\n *   .describe('Reviews code for best practices')\n *   .param('code', string('Code to review'))\n *   .param('language', enumOf(['typescript', 'python', 'go']))\n *   .build();\n * ```\n */\nexport function agentTool(name: string, agentRef: string): AgentToolBuilder {\n  return new AgentToolBuilder(name, agentRef);\n}\n\n// =============================================================================\n// WEBHOOK TOOL BUILDER (calls external URL)\n// =============================================================================\n\nclass WebhookToolBuilder<TParams extends Record<string, ParamSchema> = Record<string, never>> {\n  private state: BaseToolState<TParams> & { url: string; secret?: string };\n\n  constructor(name: string, url: string) {\n    this.state = { name, url, description: '', params: {} as TParams, requireApproval: false };\n  }\n\n  describe(description: string): this {\n    this.state.description = description;\n    return this;\n  }\n\n  displayName(name: string): this {\n    this.state.displayName = name;\n    return this;\n  }\n\n  /** Set webhook secret for authentication */\n  secret(secret: string): this {\n    this.state.secret = secret;\n    return this;\n  }\n\n  requireApproval(): this {\n    this.state.requireApproval = true;\n    return this;\n  }\n\n  hil(): this {\n    return this.requireApproval();\n  }\n\n  param<K extends string, S extends ParamSchema>(\n    name: K,\n    schema: S\n  ): WebhookToolBuilder<TParams & Record<K, S>> {\n    const newBuilder = new WebhookToolBuilder<TParams & Record<K, S>>(this.state.name, this.state.url);\n    newBuilder.state = {\n      ...this.state,\n      params: { ...this.state.params, [name]: schema } as TParams & Record<K, S>,\n    };\n    return newBuilder;\n  }\n\n  /** Build the webhook tool schema */\n  build(): AgentTool {\n    return {\n      name: this.state.name,\n      display_name: this.state.displayName || this.state.name,\n      description: this.state.description,\n      type: ToolTypeHook,\n      require_approval: this.state.requireApproval || undefined,\n      hook: {\n        url: this.state.url,\n        secret: this.state.secret,\n        input_schema: paramsToJsonSchema(this.state.params),\n      },\n    };\n  }\n}\n\n/**\n * Create a webhook tool (calls external URL)\n * \n * @example\n * ```typescript\n * const slackNotify = webhookTool('notify_slack', 'https://hooks.slack.com/...')\n *   .describe('Sends a Slack notification')\n *   .secret(process.env.SLACK_SECRET)\n *   .param('channel', string('Channel name'))\n *   .param('message', string('Message text'))\n *   .build();\n * ```\n */\nexport function webhookTool(name: string, url: string): WebhookToolBuilder {\n  return new WebhookToolBuilder(name, url);\n}\n\n// =============================================================================\n// INTERNAL TOOLS CONFIG BUILDER\n// =============================================================================\n\nclass InternalToolsBuilder {\n  private config: InternalToolsConfig = {};\n\n  /** Enable plan tools (Create, Update, Load) */\n  plan(enabled = true): this {\n    this.config.plan = enabled;\n    return this;\n  }\n\n  /** Enable memory tools (Set, Get, GetAll) */\n  memory(enabled = true): this {\n    this.config.memory = enabled;\n    return this;\n  }\n\n  /** Enable widget tools (UI, HTML) - top-level agents only */\n  widget(enabled = true): this {\n    this.config.widget = enabled;\n    return this;\n  }\n\n  /** Enable finish tool - sub-agents only */\n  finish(enabled = true): this {\n    this.config.finish = enabled;\n    return this;\n  }\n\n  /** Enable all internal tools */\n  all(): this {\n    this.config.plan = true;\n    this.config.memory = true;\n    this.config.widget = true;\n    this.config.finish = true;\n    return this;\n  }\n\n  /** Disable all internal tools */\n  none(): this {\n    this.config.plan = false;\n    this.config.memory = false;\n    this.config.widget = false;\n    this.config.finish = false;\n    return this;\n  }\n\n  /** Build the config */\n  build(): InternalToolsConfig {\n    return this.config;\n  }\n}\n\n/**\n * Create an internal tools configuration (fluent builder)\n * \n * @example\n * ```typescript\n * // Simple - just use an object\n * internalTools: { plan: true, memory: true }\n * \n * // Or use builder\n * internalTools: internalTools().plan().memory().build()\n * ```\n */\nexport function internalTools(): InternalToolsBuilder {\n  return new InternalToolsBuilder();\n}\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/** Create multiple tools from a record */\nexport function createTools(tools: Record<string, ClientTool>): ClientTool[] {\n  return Object.values(tools);\n}\n\n/** Create multiple server tools from a record */\nexport function createServerTools(tools: Record<string, AgentTool>): AgentTool[] {\n  return Object.values(tools);\n}\n",
      "type": "registry:lib",
      "target": "components/agent/lib/tool-builder.ts"
    }
  ]
}