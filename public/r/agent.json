{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "agent",
  "type": "registry:block",
  "title": "Agent Chat",
  "description": "Full-featured AI agent chat with state management, tools, and widgets.",
  "dependencies": [
    "@inferencesh/sdk"
  ],
  "registryDependencies": [
    "button",
    "https://ui.inference.sh/r/chat.json",
    "https://ui.inference.sh/r/tools.json",
    "https://ui.inference.sh/r/widgets.json"
  ],
  "files": [
    {
      "path": "registry/blocks/agent/agent.tsx",
      "content": "/**\n * Agent - Pre-composed Chat Component\n * \n * Ready-to-use chat UI built from primitives.\n */\n\nimport React, { memo, useMemo } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Bot } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport {\n  Inference,\n  ChatMessageStatusReady,\n  ChatMessageStatusFailed,\n  ChatMessageStatusCancelled,\n  ChatMessageRoleUser,\n  ChatMessageRoleAssistant,\n  ChatMessageContentTypeReasoning,\n  ChatMessageContentTypeText,\n} from '@inferencesh/sdk';\nimport { AgentProvider } from '@/components/agent/provider';\nimport { useAgent, useAgentActions } from '@/hooks/use-agent';\nimport { ChatContainer } from '@/components/agent/chat-container';\nimport { ChatMessages } from '@/components/agent/chat-messages';\nimport { ChatInput } from '@/components/agent/chat-input';\nimport { MessageBubble } from '@/components/agent/message-bubble';\nimport { MessageContent } from '@/components/agent/message-content';\nimport { MessageReasoning } from '@/components/agent/message-reasoning';\nimport { MessageStatusIndicator } from '@/components/agent/message-status-indicator';\nimport { ToolInvocations } from '@/components/agent/tool-invocations';\nimport type { AgentProps, ChatMessageDTO } from '@/components/agent/types';\nimport { isAdHocConfig } from '@/components/agent/types';\n\n// Check if message status is terminal (generation complete)\nfunction isTerminalStatus(status: string | undefined): boolean {\n  return status === ChatMessageStatusReady ||\n    status === ChatMessageStatusFailed ||\n    status === ChatMessageStatusCancelled;\n}\n\n// =============================================================================\n// Helper functions\n// =============================================================================\n\nfunction getTextContent(message: ChatMessageDTO): string {\n  const textContent = message.content.find((c) => c.type === ChatMessageContentTypeText);\n  return textContent?.text ?? '';\n}\n\nfunction getReasoningContent(message: ChatMessageDTO): string | undefined {\n  const reasoningContent = message.content.find((c) => c.type === ChatMessageContentTypeReasoning);\n  return reasoningContent?.text;\n}\n\nfunction hasTextContent(message: ChatMessageDTO): boolean {\n  return message.content.some((c) => c.type === ChatMessageContentTypeText && c.text?.trim());\n}\n\n// =============================================================================\n// Internal Components\n// =============================================================================\n\nconst DefaultHeader = memo(function DefaultHeader() {\n  return (\n    <div className=\"flex items-center gap-2 px-4 py-3 border-b\">\n      <Bot className=\"h-4 w-4 text-primary\" />\n      <span className=\"font-medium text-sm\">agent</span>\n    </div>\n  );\n});\n\nconst ExamplePrompts = memo(function ExamplePrompts({\n  prompts,\n  onSelect,\n}: {\n  prompts: string[];\n  onSelect: (prompt: string) => void;\n}) {\n  if (prompts.length === 0) return null;\n\n  return (\n    <div className=\"mt-4 space-y-2 w-full max-w-md\">\n      {prompts.map((prompt, idx) => (\n        <Button\n          key={idx}\n          variant=\"outline\"\n          onClick={() => onSelect(prompt)}\n          className=\"w-full text-left justify-start h-auto py-2 px-3 text-sm whitespace-normal\"\n        >\n          {prompt}\n        </Button>\n      ))}\n    </div>\n  );\n});\n\nconst EmptyState = memo(function EmptyState({\n  description,\n  examplePrompts = [],\n}: {\n  description?: string;\n  examplePrompts?: string[];\n}) {\n  const { sendMessage } = useAgentActions();\n\n  return (\n    <div className=\"flex-1 flex flex-col items-center justify-center text-center p-6 text-muted-foreground\">\n      <Bot className=\"h-8 w-8 mb-3 opacity-50\" />\n      <p className=\"text-sm font-medium\">how can I help?</p>\n      <p className=\"text-xs mt-1 opacity-70\">\n        {description || 'ask me anything'}\n      </p>\n      {examplePrompts.length > 0 && (\n        <ExamplePrompts prompts={examplePrompts} onSelect={sendMessage} />\n      )}\n    </div>\n  );\n});\n\nconst MessageRow = memo(function MessageRow({\n  message,\n  isLast,\n}: {\n  message: ChatMessageDTO;\n  isLast: boolean;\n}) {\n  const isUser = message.role === ChatMessageRoleUser;\n  const isAssistant = message.role === ChatMessageRoleAssistant;\n  const reasoningContent = getReasoningContent(message);\n  const isGenerating = !isTerminalStatus(message.status);\n  const hasTools = message.tool_invocations && message.tool_invocations.length > 0;\n\n  if (message.role === 'tool') {\n    return null;\n  }\n\n  if (!hasTextContent(message) && !reasoningContent && !hasTools) {\n    return null;\n  }\n\n  return (\n    <MessageBubble message={message}>\n      {isAssistant && reasoningContent && (\n        <MessageReasoning\n          reasoning={reasoningContent}\n          isReasoning={isGenerating && !hasTextContent(message)}\n        />\n      )}\n      <MessageContent message={message} truncate={isUser} />\n      {isAssistant && <ToolInvocations message={message} />}\n      {isAssistant && isGenerating && <MessageStatusIndicator />}\n    </MessageBubble>\n  );\n});\n\nconst MessageList = memo(function MessageList({\n  messages,\n  isGenerating,\n}: {\n  messages: ChatMessageDTO[];\n  isGenerating: boolean;\n}) {\n  // Show typing indicator when generating and last message is user or has no content yet\n  const lastMessage = messages[messages.length - 1];\n  const showTyping =\n    isGenerating &&\n    (!lastMessage ||\n      lastMessage.role === 'user' ||\n      !lastMessage.content?.some(c => c.type === 'text' && c.text?.trim()));\n\n  return (\n    <div className=\"space-y-4 p-4\">\n      {messages.map((message, index) => (\n        <MessageRow\n          key={message.id}\n          message={message}\n          isLast={index === messages.length - 1}\n        />\n      ))}\n      {showTyping && <MessageStatusIndicator label=\"thinking...\" />}\n    </div>\n  );\n});\n\nconst AgentContent = memo(function AgentContent({\n  className,\n  compact,\n  allowFiles = true,\n  allowImages = true,\n  description,\n  examplePrompts,\n}: {\n  className?: string;\n  compact?: boolean;\n  allowFiles?: boolean;\n  allowImages?: boolean;\n  description?: string;\n  examplePrompts?: string[];\n}) {\n  const { messages, isGenerating } = useAgent();\n  const hasMessages = messages.length > 0;\n\n  return (\n    <ChatContainer className={cn('h-full p-2', className)}>\n      {!compact && <DefaultHeader />}\n      {hasMessages ? (\n        <ChatMessages className=\"flex-1\">\n          {({ messages }) => <MessageList messages={messages} isGenerating={isGenerating} />}\n        </ChatMessages>\n      ) : (\n        <EmptyState description={description} examplePrompts={examplePrompts} />\n      )}\n      <ChatInput allowFiles={allowFiles} allowImages={allowImages} />\n    </ChatContainer>\n  );\n});\n\n// =============================================================================\n// Main Component\n// =============================================================================\n\nexport function Agent({\n  proxyUrl,\n  apiKey,\n  config,\n  name,\n  chatId,\n  className,\n  compact = false,\n  allowFiles = true,\n  allowImages = true,\n  onChatCreated,\n  description,\n  examplePrompts,\n}: AgentProps) {\n  // Create client internally - memoized to prevent re-creation\n  const client = useMemo(() => {\n    if (!proxyUrl && !apiKey) {\n      console.error('[Agent] Either proxyUrl or apiKey is required');\n      return null;\n    }\n    return new Inference({ proxyUrl, apiKey });\n  }, [proxyUrl, apiKey]);\n\n  if (!client) {\n    return null;\n  }\n\n  // Extract description and example prompts from ad-hoc config, or use props\n  const effectiveDescription = description ?? (isAdHocConfig(config) ? config.description : undefined);\n  const effectiveExamplePrompts = examplePrompts ?? (isAdHocConfig(config) ? config.example_prompts : undefined);\n\n  return (\n    <AgentProvider\n      client={client}\n      config={config}\n      name={name}\n      chatId={chatId}\n      onChatCreated={onChatCreated}\n    >\n      <AgentContent\n        className={className}\n        compact={compact}\n        allowFiles={allowFiles}\n        allowImages={allowImages}\n        description={effectiveDescription}\n        examplePrompts={effectiveExamplePrompts}\n      />\n    </AgentProvider>\n  );\n}\n\nAgent.displayName = 'Agent';\n",
      "type": "registry:component",
      "target": "components/agent/agent.tsx"
    },
    {
      "path": "registry/blocks/agent/provider.tsx",
      "content": "/**\n * Agent Chat Provider\n * \n * Uses React useReducer + Context with SDK Agent for API operations.\n */\n\nimport React, { useReducer, useRef, useEffect, useMemo } from 'react';\nimport type { Agent, Inference } from '@inferencesh/sdk';\nimport { AgentContext, type AgentContextValue } from '@/components/agent/context';\nimport { chatReducer, initialState } from '@/components/agent/lib/reducer';\nimport { createActions, getClientToolHandlers, type ActionsContext, type ActionsResult } from '@/components/agent/lib/actions';\nimport type { AgentProviderProps, AgentOptions, AgentUIStatus, ClientToolHandler } from '@/components/agent/types';\n\n/**\n * AgentProvider - Provides chat state and actions to children\n * \n * @example\n * ```tsx\n * const client = new Inference({ proxyUrl: '/api/inference/proxy' });\n * \n * <AgentProvider\n *   client={client}\n *   agentConfig={{ core_app: { ref: 'openrouter/claude-sonnet-4@abc123' } }}\n * >\n *   <MyChatUI />\n * </AgentProvider>\n * ```\n */\nexport function AgentProvider({\n  client,\n  config,\n  name,\n  chatId,\n  onChatCreated,\n  onStatusChange,\n  onError,\n  children,\n}: AgentProviderProps) {\n  // Core state via useReducer\n  const [state, dispatch] = useReducer(chatReducer, initialState);\n\n  // Refs for mutable values that actions need access to\n  const clientRef = useRef<Inference>(client);\n  const agentRef = useRef<Agent | null>(null);\n  const configRef = useRef<AgentOptions | null>(config);\n  const agentNameRef = useRef<string | undefined>(name);\n  const chatIdRef = useRef<string | null>(chatId ?? null);\n  const clientToolHandlersRef = useRef<Map<string, ClientToolHandler>>(\n    getClientToolHandlers(config)\n  );\n  const callbacksRef = useRef<{\n    onChatCreated?: (chatId: string) => void;\n    onStatusChange?: (status: AgentUIStatus) => void;\n    onError?: (error: Error) => void;\n  }>({ onChatCreated, onStatusChange, onError });\n\n  // Keep refs in sync with props\n  useEffect(() => {\n    clientRef.current = client;\n  }, [client]);\n\n  useEffect(() => {\n    configRef.current = config;\n    agentNameRef.current = name;\n    clientToolHandlersRef.current = getClientToolHandlers(config);\n  }, [config, name]);\n\n  useEffect(() => {\n    callbacksRef.current = { onChatCreated, onStatusChange, onError };\n  }, [onChatCreated, onStatusChange, onError]);\n\n  // Keep chatIdRef synced with state\n  useEffect(() => {\n    chatIdRef.current = state.chatId;\n  }, [state.chatId]);\n\n  // Create actions once (they use refs internally)\n  const actionsContext = useMemo<ActionsContext>(() => ({\n    dispatch,\n    getClient: () => clientRef.current,\n    getAgent: () => agentRef.current,\n    setAgent: (agent) => { agentRef.current = agent; },\n    getConfig: () => configRef.current,\n    getAgentName: () => agentNameRef.current,\n    getChatId: () => chatIdRef.current,\n    getClientToolHandlers: () => clientToolHandlersRef.current,\n    callbacks: callbacksRef.current,\n  }), []);\n\n  // Re-bind callbacks when they change\n  useEffect(() => {\n    actionsContext.callbacks = callbacksRef.current;\n  }, [actionsContext, onChatCreated, onStatusChange, onError]);\n\n  const actionsResultRef = useRef<ActionsResult | null>(null);\n  if (!actionsResultRef.current) {\n    actionsResultRef.current = createActions(actionsContext);\n  }\n  const { publicActions, internalActions } = actionsResultRef.current;\n\n  // Handle initial chatId or chatId changes\n  useEffect(() => {\n    if (chatId && chatId !== state.chatId) {\n      internalActions.setChatId(chatId);\n    }\n  }, [chatId, state.chatId, internalActions]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      internalActions.stopStream();\n    };\n  }, [internalActions]);\n\n  const contextValue = useMemo<AgentContextValue>(() => ({\n    state,\n    actions: publicActions,\n    client,\n  }), [state, publicActions, client]);\n\n  return (\n    <AgentContext.Provider value={contextValue}>\n      {children}\n    </AgentContext.Provider>\n  );\n}\n\nAgentProvider.displayName = 'AgentProvider';\n",
      "type": "registry:component",
      "target": "components/agent/provider.tsx"
    },
    {
      "path": "registry/blocks/agent/context.tsx",
      "content": "/**\n * Agent Chat Context\n * \n * React context for agent chat state and actions.\n */\n\nimport { createContext } from 'react';\nimport type { Inference } from '@inferencesh/sdk';\nimport type { AgentState, AgentActions } from '@/components/agent/types';\n\nexport interface AgentContextValue {\n    state: AgentState;\n    actions: AgentActions;\n    client: Inference;\n}\n\nexport const AgentContext = createContext<AgentContextValue | null>(null);\n",
      "type": "registry:component",
      "target": "components/agent/context.tsx"
    },
    {
      "path": "registry/blocks/agent/types.ts",
      "content": "/**\n * Agent Chat Types\n * \n * Types for the Agent Chat component, using @inferencesh/sdk types.\n */\n\nimport type { ReactNode } from 'react';\nimport type {\n    Inference,\n    ChatMessageDTO,\n    ChatDTO,\n    ToolInvocationDTO,\n    ChatMessageContent,\n    ChatMessageRole,\n    TaskStatus,\n    AgentTool,\n    AgentConfig,\n    File as FileDTO,\n    ClientTool,\n    ClientToolHandler,\n} from '@inferencesh/sdk';\n\n// Re-export SDK types for consumers\nexport type {\n    ChatMessageDTO,\n    ChatDTO,\n    ToolInvocationDTO,\n    ChatMessageContent,\n    ChatMessageRole,\n    TaskStatus,\n    ClientTool,\n    ClientToolHandler,\n};\n\n// =============================================================================\n// Agent Configuration\n// =============================================================================\n\n/**\n * Ad-hoc agent configuration - uses SDK's AgentConfig\n * Can include ClientTool for browser-executed handlers\n */\nexport type AdHocAgentConfig = Omit<AgentConfig, 'tools'> & {\n    /** Tools with optional client-side handlers */\n    tools?: (AgentTool | ClientTool)[];\n};\n\n/**\n * Template agent configuration\n */\nexport interface TemplateAgentConfig {\n    /** Agent reference: namespace/name@shortid */\n    agent: string;\n}\n\n/**\n * Union type for agent options\n */\nexport type AgentOptions = AdHocAgentConfig | TemplateAgentConfig;\n\n/**\n * Type guard for ad-hoc config\n */\nexport function isAdHocConfig(config: AgentOptions): config is AdHocAgentConfig {\n    return 'core_app' in config;\n}\n\n/**\n * Type guard for template config\n */\nexport function isTemplateConfig(config: AgentOptions): config is TemplateAgentConfig {\n    return 'agent' in config;\n}\n\n// =============================================================================\n// Chat State\n// =============================================================================\n\nexport type AgentUIStatus = 'idle' | 'connecting' | 'streaming' | 'error';\n\nexport interface AgentState {\n    chatId: string | null;\n    messages: ChatMessageDTO[];\n    status: AgentUIStatus;\n    isGenerating: boolean;\n    error?: string;\n    chat: ChatDTO | null;\n}\n\nexport interface AgentActions {\n    sendMessage: (text: string, files?: (Blob | FileDTO)[]) => Promise<void>;\n    stopGeneration: () => void;\n    reset: () => void;\n    clearError: () => void;\n    submitToolResult: (toolInvocationId: string, result: string) => Promise<void>;\n    approveTool: (toolInvocationId: string) => Promise<void>;\n    rejectTool: (toolInvocationId: string, reason?: string) => Promise<void>;\n    alwaysAllowTool: (toolInvocationId: string, toolName: string) => Promise<void>;\n}\n\n// =============================================================================\n// Provider Props\n// =============================================================================\n\nexport interface AgentProviderProps {\n    /** Inference SDK client instance */\n    client: Inference;\n    /** Agent configuration (ad-hoc or template reference) */\n    config: AgentOptions;\n    /** Optional name for ad-hoc agents (used for deduplication and display) */\n    name?: string;\n    /** Optional existing chat ID to continue */\n    chatId?: string;\n    /** Callback when a new chat is created */\n    onChatCreated?: (chatId: string) => void;\n    /** Callback when chat status changes */\n    onStatusChange?: (status: AgentUIStatus) => void;\n    /** Callback when an error occurs */\n    onError?: (error: Error) => void;\n    /** Children */\n    children: ReactNode;\n}\n\n// =============================================================================\n// Component Props\n// =============================================================================\n\nexport interface AgentProps {\n    /**\n     * Proxy URL for browser-safe API calls (recommended for frontend apps)\n     * @example \"/api/inference/proxy\"\n     */\n    proxyUrl?: string;\n    /** Direct API key (use only in secure environments, not recommended for browsers) */\n    apiKey?: string;\n    /** Agent configuration */\n    config: AgentOptions;\n    /** Optional name for ad-hoc agents (used for deduplication and display) */\n    name?: string;\n    /** Optional existing chat ID */\n    chatId?: string;\n    /** Additional CSS classes */\n    className?: string;\n    /** Compact mode (no header) */\n    compact?: boolean;\n    /** Allow file attachments (default: true) */\n    allowFiles?: boolean;\n    /** Allow image attachments (default: true) */\n    allowImages?: boolean;\n    /** Callback when chat is created */\n    onChatCreated?: (chatId: string) => void;\n    /** Description for empty state (used with template configs) */\n    description?: string;\n    /** Example prompts for empty state (used with template configs) */\n    examplePrompts?: string[];\n}\n\nexport interface ChatMessagesProps {\n    children: (props: { messages: ChatMessageDTO[] }) => ReactNode;\n    className?: string;\n    scrollToTopPadding?: boolean;\n}\n\nexport interface ChatInputProps {\n    placeholder?: string;\n    className?: string;\n    /** @deprecated Use allowFiles and allowImages instead */\n    allowAttachments?: boolean;\n    /** Allow file attachments (default: true) */\n    allowFiles?: boolean;\n    /** Allow image attachments (default: true) */\n    allowImages?: boolean;\n    onFilesChange?: (files: File[]) => void;\n}\n\nexport interface MessageBubbleProps {\n    message: ChatMessageDTO;\n    children?: ReactNode;\n    className?: string;\n}\n\nexport interface MessageContentProps {\n    message: ChatMessageDTO;\n    className?: string;\n    truncate?: boolean;\n}\n\nexport interface ToolInvocationProps {\n    invocation: ToolInvocationDTO;\n    className?: string;\n    defaultOpen?: boolean;\n}\n\nexport interface ToolInvocationsProps {\n    message: ChatMessageDTO;\n    className?: string;\n}\n\nexport interface MessageReasoningProps {\n    reasoning: string;\n    isReasoning?: boolean;\n    className?: string;\n}\n\nexport interface ChatContainerProps {\n    children: ReactNode;\n    className?: string;\n}\n\n// =============================================================================\n// Client Tools (types imported from SDK, helpers defined here)\n// =============================================================================\n\nexport function isClientTool(tool: AgentTool | ClientTool): tool is ClientTool {\n    return 'handler' in tool && 'schema' in tool;\n}\n\nexport function extractToolSchemas(tools: (AgentTool | ClientTool)[]): AgentTool[] {\n    return tools.map(t => isClientTool(t) ? t.schema : t);\n}\n\nexport function extractClientToolHandlers(\n    tools: (AgentTool | ClientTool)[]\n): Map<string, ClientToolHandler> {\n    const handlers = new Map<string, ClientToolHandler>();\n    for (const tool of tools) {\n        if (isClientTool(tool)) {\n            handlers.set(tool.schema.name, tool.handler);\n        }\n    }\n    return handlers;\n}\n\n// =============================================================================\n// Constants (re-exported from SDK)\n// =============================================================================\n\nexport {\n    ChatMessageRoleUser,\n    ChatMessageRoleAssistant,\n    ChatMessageRoleTool,\n    ChatMessageRoleSystem,\n    ChatMessageContentTypeText,\n    ChatMessageContentTypeReasoning,\n    ChatMessageContentTypeImage,\n    ChatMessageContentTypeFile,\n    ChatMessageStatusReady,\n    ChatMessageStatusFailed,\n    ChatMessageStatusCancelled,\n    ToolTypeClient,\n    ToolTypeApp,\n    ToolInvocationStatusPending,\n    ToolInvocationStatusInProgress,\n    ToolInvocationStatusAwaitingInput,\n    ToolInvocationStatusAwaitingApproval,\n    ToolInvocationStatusCompleted,\n    ToolInvocationStatusFailed,\n    ToolInvocationStatusCancelled,\n} from '@inferencesh/sdk';\n\n// =============================================================================\n// Widget Types (for tool output rendering)\n// =============================================================================\n\nexport const WidgetTypeUI = 'ui';\nexport const WidgetTypeHTML = 'html';\n\nexport interface WidgetNode {\n    type: string;\n    // Text/title/caption nodes\n    value?: string;\n    variant?: string;\n    size?: string;\n    weight?: string;\n    color?: string;\n    // Label\n    fieldName?: string;\n    // Image\n    src?: string;\n    alt?: string;\n    height?: number | string;\n    width?: number | string;\n    // Badge/Icon\n    label?: string;\n    iconName?: string;\n    // Button - actions attached directly\n    /** @deprecated Use onClickAction instead */\n    action?: WidgetAction;\n    /** Action triggered when element is clicked */\n    onClickAction?: WidgetAction;\n    disabled?: boolean;\n    // Input/Textarea\n    name?: string;\n    placeholder?: string;\n    defaultValue?: string;\n    required?: boolean;\n    rows?: number;\n    /** Action triggered when input value changes */\n    onChangeAction?: WidgetAction;\n    // Select/Radio\n    options?: { value: string; label: string }[];\n    // Checkbox\n    defaultChecked?: boolean;\n    /** Action triggered when checkbox is toggled */\n    onCheckedChangeAction?: WidgetAction;\n    // Layout\n    children?: WidgetNode[];\n    gap?: number;\n    align?: string;\n    justify?: string;\n    direction?: string;\n    padding?: number;\n    background?: string | { light?: string; dark?: string };\n    radius?: string;\n    /** Minimum height in pixels or CSS value */\n    minHeight?: number | string;\n    /** Maximum height in pixels or CSS value */\n    maxHeight?: number | string;\n    /** Minimum width in pixels or CSS value */\n    minWidth?: number | string;\n    /** Maximum width in pixels or CSS value */\n    maxWidth?: number | string;\n    /** Aspect ratio (e.g., \"16/9\", \"4/3\", \"1/1\") */\n    aspectRatio?: string;\n    // Spacer/Divider\n    minSize?: number;\n    spacing?: number;\n    // Form\n    onSubmitAction?: WidgetAction;\n    // Card\n    /** Treat Card as Form, collecting child inputs on confirm */\n    asForm?: boolean;\n    /** Card confirm action (used when asForm=true) */\n    confirmAction?: WidgetAction;\n}\n\n/**\n * Widget action configuration - attached directly to interactive elements\n * @example\n * { type: \"submit\", payload: { id: 123 }, handler: \"server\", loadingBehavior: \"self\" }\n */\nexport interface WidgetAction {\n    /** Action type identifier */\n    type: string;\n    /** Optional payload data */\n    payload?: Record<string, unknown>;\n    /** Handler location: 'server' (default) sends to backend, 'client' calls local callback */\n    handler?: 'server' | 'client';\n    /** Loading behavior when action is triggered */\n    loadingBehavior?: 'auto' | 'self' | 'container' | 'none';\n}\n\nexport interface WidgetFormData {\n    [key: string]: string | boolean | undefined;\n}\n\n/**\n * Widget structure\n * Note: `actions` array (card footer buttons) is deprecated.\n * Use `onClickAction` on buttons/elements instead.\n */\nexport interface Widget {\n    type: string;\n    title?: string;\n    html?: string;\n    content?: string;\n    children?: WidgetNode[];\n    /** @deprecated - Use onClickAction on individual elements instead */\n    actions?: { label: string; variant?: string; action: WidgetAction }[];\n    [key: string]: unknown;\n}\n\n// =============================================================================\n// Tool Finish Types\n// =============================================================================\n\nexport interface ToolFinish {\n    status: string;\n    result?: unknown;\n    error?: string;\n}\n\nexport const ToolFinishStatusSucceeded = 'succeeded';\nexport const ToolFinishStatusFailed = 'failed';\nexport const ToolFinishStatusCancelled = 'cancelled';\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Check if a chat message status is terminal (generation complete)\n */\nexport function isTerminalChatMessageStatus(status: string | undefined): boolean {\n    return status === 'ready' || status === 'failed' || status === 'cancelled';\n}\n",
      "type": "registry:lib",
      "target": "components/agent/types.ts"
    },
    {
      "path": "registry/blocks/agent/hooks/use-agent.ts",
      "content": "/**\n * Agent Chat Hooks\n * \n * Public hooks for accessing chat state and actions.\n */\n\nimport { useContext } from 'react';\nimport { AgentContext } from '@/components/agent/context';\nimport type { AgentState, AgentActions, ChatMessageDTO } from '@/components/agent/types';\n\n/**\n * Hook to access chat state\n */\nexport function useAgent(): AgentState {\n    const context = useContext(AgentContext);\n\n    if (!context) {\n        throw new Error(\n            'useAgent must be used within an AgentProvider. ' +\n            'Wrap your component tree with <AgentProvider>.'\n        );\n    }\n\n    return context.state;\n}\n\n/**\n * Hook to access chat actions\n */\nexport function useAgentActions(): AgentActions {\n    const context = useContext(AgentContext);\n\n    if (!context) {\n        throw new Error(\n            'useAgentActions must be used within an AgentProvider. ' +\n            'Wrap your component tree with <AgentProvider>.'\n        );\n    }\n\n    return context.actions;\n}\n\n/**\n * Hook to access a specific message by ID\n */\nexport function useMessage(messageId: string): ChatMessageDTO | undefined {\n    const { messages } = useAgent();\n    return messages.find((m) => m.id === messageId);\n}\n\n/**\n * Hook to access both state and actions\n */\nexport function useAgentContext(): { state: AgentState; actions: AgentActions } {\n    const context = useContext(AgentContext);\n\n    if (!context) {\n        throw new Error(\n            'useAgentContext must be used within an AgentProvider. ' +\n            'Wrap your component tree with <AgentProvider>.'\n        );\n    }\n\n    return context;\n}\n",
      "type": "registry:hook",
      "target": "hooks/use-agent.ts"
    },
    {
      "path": "registry/blocks/agent/internal/reducer.ts",
      "content": "/**\n * Agent Chat Internal Reducer\n * \n * Pure reducer for chat state management.\n */\n\nimport type { ChatDTO, ChatMessageDTO, AgentState, AgentUIStatus } from '@/components/agent/types';\n\n// =============================================================================\n// Action Types\n// =============================================================================\n\nexport type ChatAction =\n    | { type: 'SET_CHAT_ID'; payload: string | null }\n    | { type: 'SET_CHAT'; payload: ChatDTO | null }\n    | { type: 'SET_MESSAGES'; payload: ChatMessageDTO[] }\n    | { type: 'UPDATE_MESSAGE'; payload: ChatMessageDTO }\n    | { type: 'ADD_MESSAGE'; payload: ChatMessageDTO }\n    | { type: 'SET_STATUS'; payload: AgentUIStatus }\n    | { type: 'SET_IS_GENERATING'; payload: boolean }\n    | { type: 'SET_ERROR'; payload: string | undefined }\n    | { type: 'RESET' };\n\n// =============================================================================\n// Initial State\n// =============================================================================\n\nexport const initialState: AgentState = {\n    chatId: null,\n    messages: [],\n    status: 'idle',\n    isGenerating: false,\n    error: undefined,\n    chat: null,\n};\n\n// =============================================================================\n// Reducer\n// =============================================================================\n\nexport function chatReducer(state: AgentState, action: ChatAction): AgentState {\n    switch (action.type) {\n        case 'SET_CHAT_ID':\n            return { ...state, chatId: action.payload };\n\n        case 'SET_CHAT': {\n            const chat = action.payload;\n            if (!chat) {\n                return { ...state, chat: null, messages: [], isGenerating: false, status: 'idle' };\n            }\n            // Populate messages from chat.chat_messages (initial load and refreshes)\n            const messages = [...(chat.chat_messages || [])].sort((a, b) => a.order - b.order);\n            const isGenerating = chat.status === 'busy';\n            const status = isGenerating ? 'streaming' : 'idle';\n            return { ...state, chat, messages, isGenerating, status };\n        }\n\n        case 'SET_MESSAGES':\n            return { ...state, messages: action.payload };\n\n        case 'UPDATE_MESSAGE': {\n            const message = action.payload;\n            const existingIndex = state.messages.findIndex((m) => m.id === message.id);\n            let newMessages: ChatMessageDTO[];\n            if (existingIndex !== -1) {\n                newMessages = [...state.messages];\n                newMessages[existingIndex] = message;\n            } else {\n                newMessages = [...state.messages, message].sort((a, b) => a.order - b.order);\n            }\n            return { ...state, messages: newMessages };\n        }\n\n        case 'ADD_MESSAGE':\n            return {\n                ...state,\n                messages: [...state.messages, action.payload].sort((a, b) => a.order - b.order),\n            };\n\n        case 'SET_STATUS':\n            return {\n                ...state,\n                status: action.payload,\n                isGenerating: action.payload === 'streaming' || action.payload === 'connecting',\n            };\n\n        case 'SET_IS_GENERATING':\n            return { ...state, isGenerating: action.payload };\n\n        case 'SET_ERROR':\n            return { ...state, error: action.payload };\n\n        case 'RESET':\n            return initialState;\n\n        default:\n            return state;\n    }\n}\n",
      "type": "registry:lib",
      "target": "components/agent/lib/reducer.ts"
    },
    {
      "path": "registry/blocks/agent/internal/actions.ts",
      "content": "/**\n * Agent Chat Actions\n * \n * Action creators using the Inference SDK Agent for all API operations.\n */\n\nimport type { Dispatch } from 'react';\nimport type { Agent, Inference, ChatDTO, ChatMessageDTO } from '@inferencesh/sdk';\nimport { ToolTypeClient, ToolInvocationStatusAwaitingInput } from '@inferencesh/sdk';\nimport type {\n    AgentOptions,\n    AgentUIStatus,\n    AgentActions,\n    ClientToolHandler,\n} from '@/components/agent/types';\nimport {\n    isAdHocConfig,\n    extractClientToolHandlers,\n    extractToolSchemas,\n} from '@/components/agent/types';\nimport type { ChatAction } from '@/components/agent/lib/reducer';\n\n// =============================================================================\n// Track dispatched client tool invocations to prevent duplicates\n// =============================================================================\n\nconst dispatchedToolInvocations = new Set<string>();\n\n// =============================================================================\n// Actions Context Interface\n// =============================================================================\n\nexport interface ActionsContext {\n    dispatch: Dispatch<ChatAction>;\n    getClient: () => Inference;\n    getAgent: () => Agent | null;\n    setAgent: (agent: Agent | null) => void;\n    getConfig: () => AgentOptions | null;\n    getAgentName: () => string | undefined;\n    getChatId: () => string | null;\n    getClientToolHandlers: () => Map<string, ClientToolHandler>;\n    callbacks: {\n        onChatCreated?: (chatId: string) => void;\n        onStatusChange?: (status: AgentUIStatus) => void;\n        onError?: (error: Error) => void;\n    };\n}\n\n// =============================================================================\n// Action Creators\n// =============================================================================\n\nexport interface InternalActions {\n    setChatId: (newChatId: string | null) => void;\n    stopStream: () => void;\n}\n\nexport interface ActionsResult {\n    publicActions: AgentActions;\n    internalActions: InternalActions;\n}\n\nexport function createActions(ctx: ActionsContext): ActionsResult {\n    const { dispatch, getClient, getAgent, setAgent, getConfig, getAgentName, getChatId, getClientToolHandlers, callbacks } = ctx;\n\n    // =========================================================================\n    // Internal helpers\n    // =========================================================================\n\n    const setChat = (chat: ChatDTO | null) => {\n        dispatch({ type: 'SET_CHAT', payload: chat });\n        if (chat) {\n            // CRITICAL: Set chatId from the chat so streaming updates aren't filtered\n            // The updateMessage function filters messages where chat_id !== getChatId()\n            // Without this, all streaming updates are discarded because chatId is null\n            const currentChatId = getChatId();\n            if (!currentChatId && chat.id) {\n                dispatch({ type: 'SET_CHAT_ID', payload: chat.id });\n                callbacks.onChatCreated?.(chat.id);\n            }\n\n            const status = chat.status === 'busy' ? 'streaming' : 'idle';\n            callbacks.onStatusChange?.(status);\n        }\n    };\n\n    const updateMessage = (message: ChatMessageDTO) => {\n        const chatId = getChatId();\n        if (message.chat_id !== chatId) return;\n\n        dispatch({ type: 'UPDATE_MESSAGE', payload: message });\n\n        // Check for client tool invocations that need execution\n        const clientToolHandlers = getClientToolHandlers();\n        if (message.tool_invocations && chatId && clientToolHandlers.size > 0) {\n            for (const invocation of message.tool_invocations) {\n                if (\n                    invocation.type === ToolTypeClient &&\n                    invocation.status === ToolInvocationStatusAwaitingInput\n                ) {\n                    // Skip if already dispatched\n                    if (dispatchedToolInvocations.has(invocation.id)) {\n                        continue;\n                    }\n                    dispatchedToolInvocations.add(invocation.id);\n\n                    const functionName = invocation.function?.name || '';\n                    const handler = clientToolHandlers.get(functionName);\n\n                    if (!handler) {\n                        console.warn(`[Agent] No handler for client tool: ${functionName}`);\n                        const agent = getAgent();\n                        agent?.submitToolResult(invocation.id, JSON.stringify({\n                            error: `No handler registered for tool: ${functionName}`\n                        }));\n                        continue;\n                    }\n\n                    // Execute the handler (may return string or Promise<string>)\n                    const args = invocation.function?.arguments || {};\n                    Promise.resolve(handler(args))\n                        .then((result) => {\n                            const agent = getAgent();\n                            agent?.submitToolResult(invocation.id, result);\n                        })\n                        .catch((error) => {\n                            console.error(`[Agent] Client tool ${functionName} error:`, error);\n                            const agent = getAgent();\n                            agent?.submitToolResult(invocation.id, JSON.stringify({\n                                error: String(error)\n                            }));\n                        });\n                }\n            }\n        }\n    };\n\n    const createAgent = (): Agent | null => {\n        const config = getConfig();\n        const agentName = getAgentName();\n        const client = getClient();\n        if (!config) return null;\n\n        if (isAdHocConfig(config)) {\n            // Extract just schemas (strip handlers)\n            const toolSchemas = config.tools ? extractToolSchemas(config.tools) : undefined;\n            return client.agent({\n                ...config,\n                tools: toolSchemas,\n            }, { name: agentName });\n        } else {\n            return client.agent(config.agent);\n        }\n    };\n\n    const stopStream = () => {\n        const agent = getAgent();\n        agent?.disconnect();\n        dispatch({ type: 'SET_STATUS', payload: 'idle' });\n        dispatch({ type: 'SET_IS_GENERATING', payload: false });\n        callbacks.onStatusChange?.('idle');\n    };\n\n    // =========================================================================\n    // Public Actions\n    // =========================================================================\n\n    const publicActions: AgentActions = {\n        sendMessage: async (text: string, files?: (Blob | import('@inferencesh/sdk').File)[]) => {\n            const config = getConfig();\n            if (!config) {\n                console.error('[Agent] No agent config provided');\n                return;\n            }\n\n            const trimmedText = text.trim();\n            if (!trimmedText) return;\n\n            // Get or create agent\n            let agent = getAgent();\n            if (!agent) {\n                agent = createAgent();\n                if (!agent) {\n                    console.error('[Agent] Failed to create agent');\n                    return;\n                }\n                setAgent(agent);\n            }\n\n            // Update status\n            dispatch({ type: 'SET_STATUS', payload: 'streaming' });\n            dispatch({ type: 'SET_ERROR', payload: undefined });\n            callbacks.onStatusChange?.('streaming');\n\n            try {\n                // Pass files directly - SDK detects FileDTO by uri property, uploads Blobs\n                const { assistantMessage } = await agent.sendMessage(trimmedText, {\n                    files: files,\n                });\n\n                // Get the chatId\n                const newChatId = assistantMessage.chat_id;\n                if (newChatId && newChatId !== getChatId()) {\n                    dispatch({ type: 'SET_CHAT_ID', payload: newChatId });\n                    callbacks.onChatCreated?.(newChatId);\n                }\n\n                // Start streaming (like frontend/app's streamChat pattern)\n                agent.startStreaming({\n                    onMessage: (message: ChatMessageDTO) => {\n                        updateMessage(message);\n                    },\n                    onChat: (chat: ChatDTO) => {\n                        setChat(chat);\n                    },\n                });\n\n                // Fetch the full chat to get complete messages\n                // This is the key step that frontend/app does in streamChat\n                const currentChatId = getChatId() || newChatId;\n                if (currentChatId) {\n                    const fullChat = await agent.getChat(currentChatId);\n                    if (fullChat) {\n                        setChat(fullChat);\n                    }\n                }\n\n            } catch (error) {\n                console.error('[Agent] Failed to send message:', error);\n                const err = error instanceof Error ? error : new Error('Failed to send message');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n            }\n        },\n\n        stopGeneration: () => {\n            const agent = getAgent();\n            stopStream();\n            agent?.stopChat();\n        },\n\n        reset: () => {\n            const agent = getAgent();\n            agent?.reset();\n            setAgent(null);\n            dispatchedToolInvocations.clear();\n            dispatch({ type: 'RESET' });\n        },\n\n        clearError: () => {\n            dispatch({ type: 'SET_ERROR', payload: undefined });\n            dispatch({ type: 'SET_STATUS', payload: 'idle' });\n        },\n\n        submitToolResult: async (toolInvocationId: string, result: string) => {\n            try {\n                const agent = getAgent();\n                if (!agent) throw new Error('No active agent');\n                await agent.submitToolResult(toolInvocationId, result);\n            } catch (error) {\n                console.error('[Agent] Failed to submit tool result:', error);\n                const err = error instanceof Error ? error : new Error('Failed to submit tool result');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n\n        approveTool: async (toolInvocationId: string) => {\n            try {\n                const client = getClient();\n                await client._request('post', `/tools/${toolInvocationId}/invoke`);\n            } catch (error) {\n                console.error('[Agent] Failed to approve tool:', error);\n                const err = error instanceof Error ? error : new Error('Failed to approve tool');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n\n        rejectTool: async (toolInvocationId: string, reason?: string) => {\n            try {\n                const client = getClient();\n                await client._request('post', `/tools/${toolInvocationId}/reject`, { data: { reason } });\n            } catch (error) {\n                console.error('[Agent] Failed to reject tool:', error);\n                const err = error instanceof Error ? error : new Error('Failed to reject tool');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n\n        alwaysAllowTool: async (toolInvocationId: string, toolName: string) => {\n            const chatId = getChatId();\n            if (!chatId) {\n                console.error('[Agent] Cannot always-allow tool without a chatId');\n                return;\n            }\n\n            try {\n                const client = getClient();\n                await client._request('post', `/chats/${chatId}/tools/${toolInvocationId}/always-allow`, {\n                    data: { tool_name: toolName }\n                });\n            } catch (error) {\n                console.error('[Agent] Failed to always-allow tool:', error);\n                const err = error instanceof Error ? error : new Error('Failed to always-allow tool');\n                dispatch({ type: 'SET_STATUS', payload: 'error' });\n                dispatch({ type: 'SET_ERROR', payload: err.message });\n                callbacks.onError?.(err);\n                throw error;\n            }\n        },\n    };\n\n    const internalActions: InternalActions = {\n        stopStream,\n        setChatId: (newChatId: string | null) => {\n            const currentChatId = getChatId();\n            if (newChatId === currentChatId) return;\n\n            if (!newChatId) {\n                stopStream();\n                dispatchedToolInvocations.clear();\n                dispatch({ type: 'RESET' });\n                return;\n            }\n\n            dispatch({ type: 'SET_CHAT_ID', payload: newChatId });\n        },\n    };\n\n    return { publicActions, internalActions };\n}\n\n// =============================================================================\n// Helper: Extract client tool handlers from config\n// =============================================================================\n\nexport function getClientToolHandlers(config: AgentOptions | null): Map<string, ClientToolHandler> {\n    if (!config || !isAdHocConfig(config) || !config.tools) {\n        return new Map();\n    }\n    return extractClientToolHandlers(config.tools);\n}\n",
      "type": "registry:lib",
      "target": "components/agent/lib/actions.ts"
    }
  ]
}