{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "markdown",
  "title": "Markdown Renderer",
  "description": "High-fidelity markdown with code blocks, YouTube embeds, and zoomable images.",
  "dependencies": [
    "react-markdown",
    "remark-gfm"
  ],
  "registryDependencies": [
    "https://ui.inference.sh/r/code-block.json",
    "https://ui.inference.sh/r/youtube-embed.json",
    "https://ui.inference.sh/r/zoomable-image.json"
  ],
  "files": [
    {
      "path": "registry/blocks/markdown/markdown-renderer.tsx",
      "content": "'use client'\n\nimport { cn } from '@/lib/utils'\nimport ZoomableImage from '@/components/infsh/zoomable-image'\nimport React, { memo, useMemo } from 'react'\nimport Markdown from 'react-markdown'\nimport remarkGfm from 'remark-gfm'\nimport { isCloudInferenceUrl, getYouTubeVideoId, stripHtmlComments } from '@/lib/markdown-helpers'\nimport { YouTubeEmbed } from '@/components/infsh/youtube-embed'\nimport { CompactCodeBlock } from '@/components/infsh/code-block/code-block'\n\nexport interface MarkdownRendererProps {\n  content: string\n  className?: string\n  /** Compact mode for dense UI like chat */\n  compact?: boolean\n  /** Custom file preview renderer for cloud URLs */\n  renderFilePreview?: (props: { uri: string; filename: string }) => React.ReactNode\n  /** Custom image renderer for cloud URLs */\n  renderCloudImage?: (props: { src: string; alt?: string }) => React.ReactNode\n}\n\nconst textSizeMap = {\n  default: {\n    h1: 'text-xl',\n    h2: 'text-lg',\n    h3: 'text-md',\n    h4: 'text-base',\n    h5: 'text-sm',\n    h6: 'text-sm',\n    p: 'text-sm',\n    li: 'text-sm',\n    code: 'text-xs',\n    pre: 'text-xs',\n    blockquote: 'text-sm',\n    ul: 'text-sm',\n    ol: 'text-sm',\n    th: 'text-sm',\n    td: 'text-sm',\n  },\n  compact: {\n    h1: 'text-xl',\n    h2: 'text-lg',\n    h3: 'text-base',\n    h4: 'text-xs',\n    h5: 'text-xs',\n    h6: 'text-xs',\n    p: 'text-xs',\n    li: 'text-xs',\n    code: 'text-xs',\n    pre: 'text-xs',\n    blockquote: 'text-xs',\n    ul: 'text-xs',\n    ol: 'text-xs',\n    th: 'text-xs',\n    td: 'text-xs',\n  },\n}\n\nexport const MarkdownRenderer = memo(function MarkdownRenderer({\n  content,\n  className,\n  compact = false,\n  renderFilePreview,\n  renderCloudImage,\n}: MarkdownRendererProps) {\n  const processedContent = useMemo(\n    () => stripHtmlComments(content),\n    [content]\n  )\n\n  const textSize = compact ? textSizeMap.compact : textSizeMap.default\n  const fontClass = 'legible'\n  const paragraphClass = cn(textSize.p, 'break-words whitespace-pre-wrap my-0 py-0 not-last:mb-4 text-justify leading-relaxed', fontClass)\n\n  return (\n    <div className={className}>\n      <Markdown\n        remarkPlugins={[[remarkGfm, { singleTilde: false }]]}\n        components={{\n          // Block elements\n          h1: ({ children }) => <h1 className={cn(textSize.h1, 'font-bold my-0 [&:first-child]:mt-0 mt-8 py-0', fontClass)}>{children}</h1>,\n          h2: ({ children }) => <h2 className={cn(textSize.h2, 'font-bold my-0 [&:first-child]:mt-0 mt-8 py-0', fontClass)}>{children}</h2>,\n          h3: ({ children }) => <h3 className={cn(textSize.h3, 'font-bold my-0 [&:first-child]:mt-0 mt-8 py-0', fontClass)}>{children}</h3>,\n          h4: ({ children }) => <h4 className={cn(textSize.h4, 'font-bold my-0 [&:first-child]:mt-0 mt-8 py-0', fontClass)}>{children}</h4>,\n          h5: ({ children }) => <h5 className={cn(textSize.h5, 'font-bold my-0 [&:first-child]:mt-0 mt-8 py-0', fontClass)}>{children}</h5>,\n          h6: ({ children }) => <h6 className={cn(textSize.h6, 'font-bold my-0 [&:first-child]:mt-0 mt-8 py-0', fontClass)}>{children}</h6>,\n\n          p: ({ children }) => {\n            // Detect if paragraph contains block-level elements that can't be inside <p>\n            // This includes YouTube embeds, cloud file previews, and images\n            const hasBlockContent = React.Children.toArray(children).some((child) => {\n              if (!React.isValidElement(child)) return false\n              const props = child.props as { href?: string; src?: string }\n              // Check for YouTube links\n              if (props.href && getYouTubeVideoId(props.href)) return true\n              // Check for cloud URLs\n              if (props.href && isCloudInferenceUrl(props.href)) return true\n              // Check for images\n              if (props.src) return true\n              return false\n            })\n            // Use div for block content to avoid invalid <div> inside <p> nesting\n            return hasBlockContent && !compact ? (\n              <div className={paragraphClass}>{children}</div>\n            ) : (\n              <p className={paragraphClass}>{children}</p>\n            )\n          },\n\n          blockquote: ({ children }) => (\n            <blockquote className={cn('border-l-4 pl-4 my-2 py-0', fontClass)}>{children}</blockquote>\n          ),\n\n          // Lists\n          ul: ({ children }) => <ul className={cn('list-disc list-outside ml-5 my-0 mt-2 py-0', fontClass)}>{children}</ul>,\n          ol: ({ children }) => <ol className={cn('list-decimal list-outside ml-5 my-0 mt-2 py-0', fontClass)}>{children}</ol>,\n          li: ({ children }) => <li className={cn(textSize.li, 'my-0 mt-2 py-0 pl-1', fontClass)}>{children}</li>,\n\n          // Inline elements\n          strong: ({ children }) => <strong className={cn('font-bold', fontClass)}>{children}</strong>,\n          em: ({ children }) => <em className={cn('italic', fontClass)}>{children}</em>,\n\n          code(props) {\n            const { children, className } = props\n            const hasLang = /language-(\\w+)/.test(className || '')\n            const hasNewlines = String(children).includes('\\n')\n            const isBlock = hasLang || hasNewlines\n\n            if (isBlock) {\n              return <code className={cn(textSize.code, fontClass, className)}>{children}</code>\n            }\n            // Inline code\n            return (\n              <span className=\"inline bg-muted/30 rounded px-1 text-pink-400/80\">\n                <code className={cn(textSize.code, fontClass)}>{children}</code>\n              </span>\n            )\n          },\n\n          pre: ({ children }) => (\n            <CompactCodeBlock textSize={textSize.pre} className={cn('not-last:mb-4', textSize.pre, fontClass)}>\n              {children}\n            </CompactCodeBlock>\n          ),\n\n          // Links and images\n          a: ({ href, children }) => {\n            if (href && !compact) {\n              // YouTube videos\n              const videoId = getYouTubeVideoId(href)\n              if (videoId) {\n                return <YouTubeEmbed videoId={videoId} />\n              }\n\n              // Cloud file previews\n              if (isCloudInferenceUrl(href) && renderFilePreview) {\n                return renderFilePreview({\n                  uri: href,\n                  filename: typeof children === 'string' ? children : 'file',\n                })\n              }\n\n              // Default link\n              return (\n                <a\n                  href={href}\n                  className={cn('hover:underline', fontClass)}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  {children}\n                </a>\n              )\n            }\n            return <>{children}</>\n          },\n\n          img: ({ src, alt }) => {\n            if (!src || typeof src !== 'string') return null\n\n            if (isCloudInferenceUrl(src) && renderCloudImage) {\n              return renderCloudImage({ src, alt })\n            }\n\n            return (\n              <ZoomableImage\n                src={src}\n                alt={alt}\n                className={cn('max-w-full h-auto my-0 py-0 rounded', fontClass)}\n              />\n            )\n          },\n\n          // Table elements\n          table: ({ children }) => (\n            <div className={cn('min-w-0 overflow-x-auto my-2 border border-border rounded-md', fontClass)}>\n              <table className=\"\">{children}</table>\n            </div>\n          ),\n          thead: ({ children }) => <thead className={cn('border-b border-border', fontClass)}>{children}</thead>,\n          tbody: ({ children }) => <tbody className={fontClass}>{children}</tbody>,\n          tr: ({ children }) => <tr className=\"border-b border-border last:border-0\">{children}</tr>,\n          th: ({ children }) => <th className={cn('px-3 py-1.5 text-left text-xs text-muted-foreground', fontClass)}>{children}</th>,\n          td: ({ children }) => <td className={cn('px-3 py-1.5 text-sm', fontClass)}>{children}</td>,\n\n          // Horizontal rule\n          hr: () => <hr className=\"my-2 border-t\" />,\n\n          // Strikethrough\n          s: ({ children }) => <s className=\"line-through\">{children}</s>,\n        }}\n      >\n        {processedContent}\n      </Markdown>\n    </div>\n  )\n})\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/blocks/markdown/lib/helpers.ts",
      "content": "// Shared markdown utilities\n\n/**\n * Detect if URL is from cloud.inference.sh\n */\nexport function isCloudInferenceUrl(url: string): boolean {\n  try {\n    const urlObj = new URL(url)\n    return urlObj.hostname === 'cloud.inference.sh'\n  } catch {\n    return false\n  }\n}\n\n/**\n * Extract YouTube video ID from various URL formats\n */\nexport function getYouTubeVideoId(url: string): string | null {\n  try {\n    if (!url) return null\n    const urlObj = new URL(url)\n\n    // youtu.be format\n    if (urlObj.hostname === 'youtu.be') {\n      return urlObj.pathname.slice(1)\n    }\n\n    // youtube.com formats\n    if (urlObj.hostname === 'youtube.com' || urlObj.hostname === 'www.youtube.com') {\n      // Watch URLs: youtube.com/watch?v=VIDEO_ID\n      if (urlObj.searchParams.has('v')) {\n        return urlObj.searchParams.get('v')\n      }\n      // Embed URLs: youtube.com/embed/VIDEO_ID\n      if (urlObj.pathname.startsWith('/embed/')) {\n        return urlObj.pathname.split('/')[2]\n      }\n    }\n\n    return null\n  } catch {\n    return null\n  }\n}\n\n/**\n * Strip HTML comments from markdown content\n */\nexport function stripHtmlComments(content: string): string {\n  return content.replace(/<!--[\\s\\S]*?-->/g, '')\n}\n\n/**\n * Heuristic: determine if a string is likely Markdown rather than plain text\n */\nexport function isLikelyMarkdown(input: string): boolean {\n  if (!input) return false\n  let score = 0\n  \n  // Headings (# ...)\n  if (/(?:^|\\n)\\s{0,3}#{1,6} \\S/.test(input)) score += 2\n  // Bold text\n  if (/\\*\\*[\\s\\S]*?\\*\\*/.test(input)) score += 1\n  // Italic text\n  if (/(?:^|[^*])\\*[^*\\s][\\s\\S]*?\\*(?:[^*]|$)/.test(input)) score += 1\n  // Lists (-, *, +, or ordered)\n  if (/(?:^|\\n)\\s{0,3}(?:[-*+] |\\d+\\. )\\S/.test(input)) score += 1\n  // Links/images\n  if (/!\\[[^\\]]*\\]\\([^)]+\\)|\\[[^\\]]+\\]\\([^)]+\\)/.test(input)) score += 2\n  // Code blocks or inline code\n  if (/(?:^|\\n)```[\\s\\S]*?```/.test(input) || /`[^`\\n]+`/.test(input)) score += 2\n  // Blockquote\n  if (/(?:^|\\n)\\s{0,3}>\\s?\\S/.test(input)) score += 1\n  // Tables (GFM)\n  if (/(?:^|\\n)\\|[^\\n]*\\|\\s*(?:\\n)\\s*\\|?\\s*:?-{3,}:?\\s*(?:\\|\\s*:?-{3,}:?\\s*)+\\|?/.test(input)) score += 2\n  // Horizontal rule\n  if (/(?:^|\\n)\\s{0,3}(?:-{3,}|_{3,}|\\*{3,})\\s*(?:\\n|$)/.test(input)) score += 1\n  \n  return score > 0\n}\n\n",
      "type": "registry:lib",
      "target": "lib/markdown-helpers.ts"
    }
  ],
  "type": "registry:block"
}